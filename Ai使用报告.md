&emsp;&emsp;@author 巷北<br>
&emsp;&emsp;@time 2025.11.26 20:42<br>
&emsp;&emsp;"母球所到之处, 即是心中所想"<br>

# 简介 
&emsp;&emsp;自从今年八月份, 将自己的问题完全分析过后, 也学到了很多东西. 但不行的是, 就像软件需要更新一样, 应对自己的各种心理情况的方法, 也需要随时更新. 我期望能按部就班地进行下去, 但现实却恰恰相反, 总会有东西阻碍着你. 所以这里呢, 就是记录所有阻碍着我的"东西", 供后续参考. 要是不记录下来的话, 过了一段时间后又忘了, 但当再次遇到类似问题时, 却又陷入束手无策的状态, 这必然是不应该的.  <br>
&emsp;&emsp;下面的第一个内容, 是我前段时间反思的, 不过写在了别的地方, 我便拿了过来, 方便汇总整理.  <br>

- [个人反思](#个人反思)
- [2025.11.26](#20251126)
    - [反馈](#00反馈)
- [2025.12.05](#20251205)
    - [十天近况](#十天近况)
    - [原因](#原因)
    - [反思](#反思)
    - [反馈](#01反馈)
    - [再反馈](#再反馈)
    - [再再反馈](#再再反馈)
    - [再再再反馈](#再再再反馈)
- [2025.12.22](#20251222)
    - [面向对象](#面向对象)
    - [认识](#认识)
    - [其它](#其它)
- [2025.12.30](#20251230)
- [2026.01.01](#20260101)
    - [问题](#问题)
- [2026.02.06](#20260206)
    - [近况](#近况)
    - [问题](#问题)

## 个人反思
&emsp;&emsp;这段时间, 一直在配置`neovim`, 差不多配置了`10`天左右吧, 到现在小有成型. 其实前面的也都还好, 语言不同, 插件不会配置, 这些问题也都慢慢解决了. 但最让我头疼的是`lsp`的配置. 确实十分头疼.  <br>
&emsp;&emsp;可能比较简单的部分, 问问`ai`就很容易解决, 但是, 如果只是单纯地问`ai`, 一点也都不思考的话, 到后面很难自定义修改, 导致后面的路越走越窄, 最后就陷入"错了问`ai`, 仍错接着问`ai`"的循环中, 最后都无法解决的痛苦之中.  <br>
&emsp;&emsp;对于我自己呢, 靠着`ai`能快速学习很多东西, 下面罗列一些吧. `Ai`的使用, `vim`等的基础配置, 嵌入式理解, `C`指针, `C++`面向对象深入, 数据库理解等等. 对于`Ai`, 是纯软件, 只不过是一些简单的快捷键操作. 语言方面, `C`和`C++`是之前学过的, 但是理解不深入, 后续借助`Ai`以及自己对`Python`的理解, 很容易地移植到这两个语言中. 对于嵌入式, 数据库等, 则是自己不明白的地方问`ai`, 最后总会搞懂, 建立自己的心理表征. 它们几乎都会有资料查询, 而且配置代码不多(`C`和`C++`除外).  <br>
&emsp;&emsp;但配置`neovim/vim`则完全不同. 新的语言, `lua/vimscript`, 不熟悉的机制和接口, 以及不熟练的`vim`操作...  <br>
&emsp;&emsp;当然, 两个月前第一次配置, 确实是十分头疼, 最终还是选择了放弃, 虽然用着`vscode`, 但强迫自己放弃鼠标, 改用`vscode`中的`vim`操作, 练习了两个月. 两个月后, 时机成熟, 便打算移植到`neovim`中来.  <br>
&emsp;&emsp;前面顺风顺水, 有着别人的代码参考. `lua`语言跟`python`很像, 也能迅速学习. 而且这个时候`ai`用的也比较少, 因为主要写的是映射相关的代码, `neovim`接口方面也是比较固定的, 很好更改. 等后续配置`lsp`的时候, 就不行了. 因为参考文档代码是`22`年的, 而最近`neovim`的`lsp`更新了, 接口也更新了, 所以无法适配. 问`ai`的话, 它总会拿着老的`lsp`接口回答, 粘贴上的话, 毫无疑问, 都是报错的.  <br>
&emsp;&emsp;那段时间的心理很复杂. 一方面, 能自己写`lua`配置`neovim`的按键映射了, 但也是仅限于此, 因为其它接口都不清楚, 而且对于`neovim`的实现机理也不明白, 整体仍呈现黑盒状态. 另一方面, `neovim`的文档很多很长, 我不知道哪些对我有用, 哪些对我没用, 怎么看, 怎么用, 都不清楚. 所以, 最后还是处于初始阶段, 一直整理代码架构(不过有一说一, 架构整理好了, 后续写代码真的十分清晰).  <br>
&emsp;&emsp;再详细描述一下当时的状态吧, 供后续参考(之前在学嵌入式时, 也有过这种迷茫状态, 但最终还是克服了. 什么状态呢?怎么克服的呢?我也都忘记了, 所以这里记录一下十分有必要). 对自己具备快速学习某种语言的能力而高兴, 但是, 缺少独立开发的能力. 欠缺读文档的能力. 过于依赖`ai`, 平时虽然能解决大部分问题, 也能学到很多东西, 但是, 像这种接口, 配置方面的问题, 如果它解决不了的话, 手足无措. `github`下方的`README`, 不会主动去看, 有问题不是选择看`README`, 而是选择去问`ai`. 有些`csdn`, `b`站视频, 其实很不错, 虽然不能直接解决问题, 但可以提供代码参考. 当时就不会选择这么做, 第一选择还是问`ai`.  <br>
&emsp;&emsp;最后怎么解决的呢? 我觉得, 最后还是稍微深入了解了一下`neovim`, 注意, 也只是浅浅地了解了一下, 边足以建立个人认识. 怎么弄的呢?  <br>
&emsp;&emsp;其实也是分析了很久. 分析了个人学习语言和库的不同, 应该在`lua`文档哪里, 这里不再重复. 最后发现, 正常学习, 总会有反馈(比如嵌入式, 硬件反馈, `manim`则是视频反馈), 来论证你做的是否正确. 而有些库的学习, 是一个黑盒, 缺少反馈. 比如配置`neovim`, 开始容易, 是因为终端界面反馈, 说明你做的没问题, 按键映射反馈, 也说明你做的没问题. 可是到了`lsp`, 一直报错, 缺少反馈, 就很头疼, 于是便陷入循环问`ai`的过程中了. 另外, 还有项目编写能力. 别人写好的库, 其实就是一个非常好的`lua`和`neovim`接口配合过程代码集合. 但是总是害怕去看, 因为太长, 太多, 结构太复杂(因为有时候我自己编写的代码, 设计的结构, 个人必然十分清晰, 但是外人来看, 很难看懂. 即使说明了结构, 我觉得他或许总会纠结于某个函数, 某个变量什么意思, 而一直困惑).  <br>
&emsp;&emsp;最后, 我打算去复刻一个插件. 这个插件就是`nvim-tree`. 感觉可能很复杂, 但是配合着`ai`, 我迅速理解了底层实现原理, 并且学了部分`neovim`的接口. 恍然大悟.  <br>
&emsp;&emsp;再此基础上, 再去配置`lsp`, 就好很多了. 因为我清楚了是什么, 而且了解了部分的`neovim`的接口, 所以就愿意主动去看文档了, 查看不同, 最后, 配置了`lua`的`lsp`, 然后`python`的`lsp`, `c++`的`lsp`(虽然说着很简单, 但是, 配置`lsp`还是不好配置啊), 解决了很多很多问题. 而且对后续环境自动化搭建有了一定的设想.  <br>
&emsp;&emsp;不论怎么说, 加油吧!!  <br>

## 2025/11/26

&emsp;&emsp;今天的心情, 整体上来说, 十分地乱. 没有目标, 没有目的. 什么都需要做, 什么也都想做, 但就是提不起兴趣来. 昨天其实也打算好了, 今天要做什么, 虽然快速过了一遍, 但被其他东西压着身, 导致这些事一点也没干....  下面就罗列一下待做的事吧, 包括老师布置的任务, 但大部分, 其实还是我自己内心构造出来的, 不做也没事, 但我一直想做, 却又一直拖着...  <br>

- 数据库的`ER`图, 周五(后天交), 昨天(周二)打算今天(周三)看`linux`操作系统内核的书, 所以`ER`图放到明天(周四)弄. 
- 数据库的结课实验前端部分整体还没有思路弄, 后端操作部分也没有思路弄.
- 嵌入式实验(总共十一篇)还没有写, 虽然之前深入学了, 有很多底层内容, 可以直接放入, 但是, 现在不想写...
- `web`实验没写. 虽然很简单, 但是现在也不想写, 因为没说截止日期. 
- 人工智能实验也没写. 算法代码虽然都弄完了, 但是不想写...
- 想了一下, 实验报告不想写的原因, 可能是因为存在数据库这座大山, 导致自己不太想去做. 
- 今天看了操作系统内核, 里面有些知识跟嵌入式相关, 一看就懂, 有些是汇编等其它我不太了解的东西, 比较想去了解, 弄清楚操作系统底层的实现原理, 为后续算法学习, 构建我自己的数学相关软件做好铺垫.  
- 今天上午几个小时过了一遍那本书, 下午的时候, 又配置了`linux`部分`neovim`的运行代码. 没想到几十分钟就搞定了. 后来呢, 发现`linux`端写代码太舒服了, 又有了将我的电脑更换为`linux`操作系统的想法. 这样写代码一定非常舒服. 可是又有很多的顾虑, 最主要的是, 嵌入式代码烧录, 如何从`linux`端烧录到`stm32`呢? 我没有查, 但感觉环境配置就需要很多的时间. 最后, 还是有想分析`linux`内核的想法, 这样需要做一下操作系统的相关实验. 我是很想做的, 但是, 上面有很多事情压着, 我也不敢去做. 
- 还有人工智能等相关的数学, 我自己还想再深入看看, 分析一下的...

&emsp;&emsp;总体来看, 差不多就这么多吧. 上面其实不仅是待做的事情, 也将我自己内心的顾虑说了出来. 但还有没说完全, 下面再来说说此时内心的顾虑吧. <br>

- 昨天配置好`c++ lsp`相关的东西, 脑海里一直在思考着自动化:如何自动分析出项目中的`C++`相关库路径, 并放到`.json`呢? 今天弄好`linux`后, 想着完全转为`linux`也很不错, 但是`powershell`相关自动化配置语言, 是否还需要学习呢? 
- 另外, `c++`相关配置的`cmake`语法, 也需要学习的. 
- 想重新深入分析一下算法, 数据结构, 但现实却是不允许啊. 
- `web`什么的也都想弄, 但是被上面的东西压着, 也没动力进行下一步...
- 另外, 今天弄了`linux`, 发现, 很多命令行都是`ai`的, 直接`copy`就可以, 但是, 却没有在脑海里有任何停留. 

&emsp;&emsp;或许说完了. 什么感觉都能做, 最后什么也没有做. 本来之前想着配置好`lsp`, 能专心写代码, 但昨天弄好之后, 发现配置也并不容易. 而且, 我只是配置好了`python lua c/c++`, 还有`java`等语言没有配置好. 现在能写写代码了, 但是, 却力不从心, 什么都不想写.  <br>
&emsp;&emsp;带着这种消极的心态, 我写下了上面的问题. 下面应该来看, 如何解决了. 不过说实话, 我确实也没好的解决方法, 要是有好的解决方法, 也没必要再写这些东西了... 怎么感觉写完上面的这些后, 更加消极了, 哈哈...  <br>
&emsp;&emsp;仔细回顾一下, 嵌入式深入学习, 其实也就一个多月的时间, 能明白很多很多很多东西. 为什么呢? 但其实那段时间里, 也曾盲目过, 但是没有及时记录下来. 我也忘了什么原因了. 最后, 应该还是面向对象吧, 激励着我去深入分析, 有很多不懂的, 问了`ai`, 大部分其实都能解决. 有些语言问题, 也会在重复地编写代码之下, 能够熟练掌握并应用.  <br>
&emsp;&emsp;另外, 之前在`lua`中也分析到了, 总会有可视化的反馈给你, 正向激励着你努力奋进的.  <br>
&emsp;&emsp;所以, 我们当下, 先抛去所有事物, 只去看最关键的部分, 卸下重担, 只专注于那一个部分即可. 那么目前最关键的那部分是什么呢? 数据库.像这种实验报告的东西, 又不是非得这周交, 似乎还有两三周的时间去做写, 没必要太过于着急. 那么这段时间, 我们就以数据库为中心专注学习吧, 摒弃一切杂念, 就像专注深入嵌入式那样深入数据库, 体会其中的乐趣, 不好吗? 后续开发准备肯定也是需要`web`相关知识的, 我们也可以用数据库这部分实现的东西, 去准备`web`的结课报告, 不也是一件很好的事吗?  <br>

### 00反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.11.26 23:13  
&emsp;&emsp;管它呢, 焦虑什么啊, 干就完了. 刚才弄了弄`ER`图, 其实也就那样. 其它的那些东西不也就那样吗? 很多东西, 你不去做, 看起来都非常庞大, 但凡做做, 会发现, 也就那样. 实验报告虽然很多, 但是实验都做完了, 代码也都有, 只是报告没写而已, 平时的时候写写, 不也早就会完成吗? <br>

## 2025/12/05
&emsp;&emsp;@author 巷北<br>
&emsp;&emsp;@time 2025.12.05 17:11  <br>

&emsp;&emsp;今天的心情(昨天的吧?)感觉也没那么糟糕, 可能有了上面的参考(反馈?分析?)吧, 这样后续心情不好(学习编程层面的), 也能有例子看看, 缓解一下. 想了想, 还是来记录一下心情不好的原因及状态, 当然, 也有解决方案, 仍能提供后续参考. 不过, 刚才点进来, 又看了看上面写的内容, 确实不错, 那不如直接将这十天(`11.26 - 12.05`), 干的事, 简单说说吧, 主要是挑些重要的, 印象深刻的说说吧.  <br>

### 十天近况

&emsp;&emsp;首先要说明, 这个文档, 目的是记录学习编程时遇到的挫折, 受挫, 心情不好, 等等可能导致效率低下的情形/情况/情境, 以及记录解决这些问题/重振士气时的方案/策略/选择. 所以, 这并不会像日记/周记等, 定时记录自己表现的文档. 每次写什么, 都看当时的心情, 有时, 可能会因为没有头绪, 而感到低落, 那么写的风格会比较悲观; 有时找到了解决方案, 那么风格会比较开朗. 但是不论怎么, 以后可能不会出现这种"十天近况"的周记似的分段, 因为下一次写, 我也不知道会是什么时候, 下周? 一个月后? 都不一定. 所以, 一切都存在未知性, 当时的心情如何, 我也不知道, 全凭感觉, 完全随机, 格式不固定(但是仍会标记时间).  <br>

- 看了`linux`内核相关书籍, 里面有关于`linus`编写`linux`时的一些情况. 首先, 他有一台计算机(裸机, 无操作系统), 其次, 他有编写代码的环境(能编写代码, 编译代码, 并且能将相关代码放到计算机中运行的环境), 最重要的是, 编写操作系统内核代码, 计算机端能有反馈(猜测的, 具体如何, 我也不清楚, 但肯定有反馈的方式), 当然, 还有开源的操作系统`Minix`, 以及`minix`的相关书籍. 除了这些实体东西外, 还有内驱力: 个人兴趣(兴趣驱动), 以及解决个人实际问题(问题驱动).  
    - 上面的内容, 总结如下:
        - 良好的编写代码/运行代码的环境.
        - 良好的可视化的反馈.
        - 可参考的开源代码/书籍.
        - 兴趣驱动.
        - 问题驱动.
    - 当然, 这些内容, 肯定是结合我自身学习情况总结的. 可能并不完全, 但对我自己而言, 足够了. 当然, 我们也能在`linus`开发`linux`内核时, 看到上面总结的缩影(其实就是我一开始写出来的, 哈哈). 
    - 这五条并不是都要在一起的, 比如问题驱动, 对于个人而言, 尤其是大学时期, 接受被动教育学习, 较难带着问题思考. 但是, 历史上, 很多东西的发展, 离不开问题的驱动. 不过, 学习编程时(我自己), 总能看到上面的影子, 从而能给予良好的反馈.
    - 另外, 当今是`ai`时代, 跟`linus`开发时的学习环境还是有很大的不同的. 那个时代, 身处欧洲, 不知道他是怎么获取信息的, 毕竟信息化时代还未普及全球. 而如今的我们, 可以向`ai`问各种各样的内容, 打破信息壁垒. 不过, 当时的`os`, 存在很多问题的, 这些问题, 也驱动着`linus`去解决. 现在呢, `os`发展较为成熟, 我们也只能从课本上学习, 或者实验中学习(可是, 实验中学习, 也是被动学习, 你是抱着我去完成这个实验的思想去做实验呢, 还是抱着开发`os`的思想去做实验呢?), 收效极为有限. 
    - 这部分说的有点多, 但其实非常简单, 就是"我看了`linus`开发`linux`时的情况". 不过阅读的时候, 也没想太多, 这些总结, 也就是写的时候分析了一下, 感觉还是很清晰的. 

- 有了想写操作系统的想法.
    - 为什么呢? 
        - 之前说的`neovim`的配置, 其中就有, 自己简单复刻了`nvim-tree`, 知道了是什么, 明白了接口, 之后写相关脚本轻松了很多, 查阅相关文档, 阅读起来也很明确了. 突破进阶的点, 就是自己尝试复刻`nvim-tree`后发现, 也就那样, 朴实无华, 并没有多么困难. 我想, 编写操作系统的话, 表面上看起来, 非常庞大, 但是, 该操作系统仅面向个人, 用不到很多保护性代码, 实现关键细节就行, 所以, 也没有想象中的那么复杂(难度肯定是有的).
        - 另外, 阅读的`linux`内核的书中, 说了, `linux 0.12`版本内核代码, 才两万行, 并不是很多. 
        - 复刻/重写, 才能有自己更深入的理解. 
        - 兴趣驱动. 此时产生了浓厚的兴趣. 我曾深入地学习过嵌入式, 对于`stm32`的运行, 有了基本了解, 但是, 对于`os`, 底层细节驱动并不清晰, 所以迫切地想知道其底层驱动实现原理.
        - 问题驱动. 对计算机硬件跟软件端交互, 存在问题. 怎么实现的呢? 
    - 有了想法之后, 便要具体实现了. 上面说的五条, 其中兴趣驱动, 问题驱动, 包含了, 那么, 还缺少前三条(我不说细节了, 就用第几条表示了, 具体可以回看上面). 那么, 怎么弄呢?
        - 关于代码的编写, 运行, 编译这方面, 我没太细致地考虑过, 当时或许只是单纯地认为, 编译一下就可以. 所以主要想着弄可视化反馈的东西.
        - 可视化反馈的东西, 最简单的其实就是再搞一台电脑. 但是没有这么多钱, 肯定不合适. 后面, 我觉得`stm32`是不是也可以运行`os`呢, 于是便`ai`了解了一下, 确实能运行`os`, 但是是实时`os`, 跟计算机的`os`还是不太一样. 后面, 我又从`ai`那里了解到了工控主机. 所以便从淘宝/京东/闲鱼各种搜工控主机. 有便宜的, 也有贵的. 不过现在又存在一个问题, 怎么将我的`os`代码放入测试运行呢? 是否可以反复运行测试呢? 商家只提供机器, 不提供教程, 没办法, 只能问`ai`. 从`ai`那里了解到, 似乎不可以. 现实的`os`编写测试运行, 都是在虚拟机上进行测试, 然后再装到实体机上. 于是, 我又从`ai`那里了解到了虚拟机`qemu`, 很不错的测试`os`的软件.
            - 另. 上面问了很多次`ai`, 但是`ai`并没有一次性给出我想要的结果. 为什么呢? 肯定是我询问方式和侧重不同. 一开始, 我的目标就是准备一台实体机(完全仿照`linus`), 所以, 询问层面, 也是更倾向于实体机, 而不是虚拟机. 后面了解到实体机编写`os`并不现实, 转而才打起了虚拟机的注意. 所以说, 靠`ai`获取有用的信息, 并不是一次性就能获取的, 你的想法, 见识, 决定着你使用`ai`的高度.
        - 可视化的东西搞到手了, 编译环境上犯了难.
            - 这部分, 我是一直问着`ai`, `ai`也能给出方案. 我的目的也很简单, 就是在`qemu`中, 显示好我编写的`hello world`即可(之前觉得, 第一次学习某种语言的时候, 输出`hello world`, 是很可笑的, 因为太简单了. ), 可是却一直实现不了. `ai`给的方案, 总是我不熟悉的, 所以, 只能盲目地选择相信. 若要问为何不系统地学习一下, 可是, 我的目的很简单, 就是输出`hello world`啊, 系统性地学习什么呢? 资料从哪来呢? 只能从`ai`获取啊. 
            - 我试了`windows`端, 发现总有问题, 又试了`linux`端(上周的事了, 因为上周也是操作系统实验时弄的, 现在我也刚好上着操作系统实验, 哈哈), 反复编译测试了许久, 最终的结果还是不行. 
            - `hello world`都输出不了, 那还写什么`os`, 哈哈. 
        - 所以, 放弃了`ai`, 转而去`b`站, `csdn`等平台, 搜寻答案. 最终还是找到了. 它的内容完全符合我的期望, 编写`os`, `qemu`虚拟机端编写, 整体`6000`行左右. 怎么样, 熟悉吧, 上面的第三条. 虽然一二条没搞好, 但是搞定了第三条, 相当于把一二条都搞定了.
            - 为什么这里说一二条都搞定了呢? 因为符合期望的那个视频, 是个卖课的, `700`多吧(`700`多好像不止写`os`这个, 还有其它的项目). 我肯定是不会买的, 所以去闲鱼搜, 还是找到有人在卖, 我买了, 花了`0.1`元, 几乎包含他的所有项目, 十分齐全(这样做对吗?).
        - 由此, 上面的五条集齐了(虽然跟着教程, 环境方面, 可视化方面的配置, 还是很难搞, 但是比起盲目地问`ai`, 已经好很多了)

- 剩下的时间, 就是跟着教程学习编写`os`喽.
    - 他的整体项目中, 内置了个小项目, `200`行代码, 编写一个小型的`os`, 我一直看着这个, 先宏观了解一下.
        - 因为有嵌入式的学习经验, 所以我十分清楚, 单纯地看视频, 写代码, 肯定是不行的. 重要的是有思考过程.
        - 这个阶段, 我会看视频, 虽然看不懂, 但是会把代码写下来, 然后运行测试一下, 接着问`ai`, 增强自己的理解. 
        - 之后, 会像现在一样, 写个思考文档. 把自己所有的心理表征写下来, 让自己有一个清晰的认识. 
    - 由于我个人不会仅限于他教程中的内容, 总想尝试`diy`编写一些代码, 所以问的会十分深入, 直至完全明白, 才进行下面的内容. 因为我知道, 只为了赶进度, 为了看完视频而学习, 是没有用的, 深刻理解之后, 再往下进行, 才最有帮助.
    - 这个时候呢, 学习了一些汇编代码, 并且计算机底层的代码编译方式, 也有了一定的了解, 像汇编+`C`语言混合编译, 等等. 另外, 也写了写`makefile`脚本, 有了一定的认识. 
    - 现在着重说说上面的第二条, 可视化方面吧. 这里的可视化, 其实就是`debug`层面的, 并不是说虚拟机端运行, 输出`hello world`这些, 而是通过`gdb`调试, 查看虚拟机内部, 各个寄存器存储的内容. 每执行一行代码, 目标寄存器的内容是否能如期地变化(到目前为止, 一切皆符合我的预期). 虽然代码是别人的, 但是可视化都是我自己搞出来的. 
        - 教程是通过`vscode`编写的, 我虽然有`vscode`, 但是我不愿意用, 我还是喜欢用终端. 所以需要添加许多额外的配置. 以前`gdb`调试, 没用过, 我知道`python`有类似的, 之前学习过, 但是`C`语言的, 确实是没用过. 所以, 专门学习了一下, 并且写好了对应的脚本, 可以完美地运行, 可视化方面也打破了壁垒(当然, 脚本不是一次性写好的, 是按照需求, 一点一点补充的.)
    - 至于为什么要搞得这么麻烦, 是因为, 后续我希望用`C++`开发一个软件(有了具体的设想), 所以环境等方面的问题都需要专门解决的. 肯定不是等后续开发的时候, 专门去解决, 不如将这些可能用到的东西, 提前搞一搞, 位后续做做准备, 多了解一下, 也是很不错的.

- 由于`os`弄得太过顺利了, 所以昨天的时候吧, 又打算着手弄另一个东西了. `C`语言重写一下数据结构, 一直弄到了今天. 这部分才是困扰我的所在, 而并不是`os`, 所以, 这里只是简单地描述一下, 后面详细地说说.
    - `C`语言重写数据结构, 也非常简单, 但是我不想仅限于此. 我想的是, `C`语言底层封装, 编译后能被`python java lua`等其他语言调用.
    - 这个想法, 其实并不是昨天才想到的, 而是很早就有疑问了. 比如`C`端跟`python`端, 语言是如何交互的? 以前, 可能会认为, `.c`文件, `.py`文件, 相互导入即可, 可能需要一些中间库的搭配. 可是`python`太慢了, 这么做, 肯定是有问题的. 那么是怎么弄的呢? 
        - 这个疑问一直有, 但其实早就解决了, 怎么解决的呢, 问的`ai`.
        - 我是这么问它的, `python`的`numpy`, 是一个高性能的数学库, 底层是`C`编写的, 可是, `python`端怎么调用的呢? `pytorch`也是同理, 等等等等.
        - 但是似乎也用`lua`配置`neovim`这段时间, 产生过以为, 比如, 用`C`编写的一个主题库, 通过`lua`编写相关接口后, 就可以被`neovim`调用, 那么, 这个接口是如何协调两个语言的呢?
        - `ai`告诉我一个关键性文件, `.dll`文件, 动态编译库. `.dll`文件, 很早就从手机端见过, 电脑端也见过, 但具体是什么, 也不清楚. 好了, 现在清楚了, 哈哈.
    - 所以说, 我之前只是知道这么弄可行, 但具体如何操作, 确实没弄过, 所以, 昨天打算弄弄, 因为感觉也不算困难.
    - 其它具体的, 下面再说吧. 

&emsp;&emsp;整体上来看, 这`10`天差不多就干了这些事吧. 复杂吗?(复杂)困难吗?(困难)学到真东西了吗?(学到了)所以说, 仅仅会用某种语言, 会用某种语言的库, 完全是不够的, 还需要会准备环境, 搭建好能够运行的环境, 似乎比单纯地写代码还要重要. 刚开始学编程的时候, 就知道, `python`比`c/c++`简单. 可是所谓的简单是指哪方面的呢? 以前可能觉得, 指的是语法层面. 但是其实语法层面是最不重要的, 因为`python`也有独属于自己的特性, 学起来也不容易. 目前来看, 我觉得, 这里的简单, 应该指的是环境配置上的简单, 而不是语言/写代码层面上的简单(当然, 如果后续我能熟练创建各种`C/C++`环境的配置(包括用户端编写代码, 还有底层`os`/汇编相关的代码), 可能也会觉得简单, 哈哈).  <br>

### 原因

&emsp;&emsp;昨天的时候, 也只是觉得, 简单弄一下就好, 同样, 还是从`C`端写个函数, 输出`hello world`, 然后在`python`端调用这个函数, 输出`hello world`. 最后也没有实现, 哈哈. 所以说, 输出`hello world`这么困难吗? 我是先写好了整体的框架, 并且写了对应的`CMakeLists.txt`文件. 当然, 也是跟`ai`学的. 并不需要一次性记住, 我只需要知道, 我的目的是导包, 能跨文件访问数据, 并且能实现`Clang`代码自动补全即可. 这部分很简单, 搞得也很快. 之后, 又写了相关的脚本文件, 方便编译运行. `Makefile`文件, 可以很容易地写编译脚本, 但是`CMakeLists.txt`似乎是不好实现. `windows`端又不支持`.sh`脚本编写, 所以我只能编写`.ps1`的`powershell`脚本文件. 不过好在之前有经验, 实现起来也不困难.  <br>
&emsp;&emsp;不过, 当时也是遇到了困难. 问题是, `CMake`编译参数, 不支持`powershell`的参数变量. 由于当时写了挺多代码, 一开始没问题, 后面集成封装了一下, 发现总是报错, 问题又不知道在哪. 问`ai`, 也解决不了. 此时, 我就又重新写一个脚本, 逐步进行测试, 最终找到问题所在, 也就是上面说的原因. <br>
&emsp;&emsp;整体上, 没太大问题了, 能编译了. 接下来, 就需要`python`端的编译即可. 我了解了一下, 发现`pybind11`, 用作`C++`的移植, 是很不错的, 所以结合`ai`, 写出了相关代码, 并成功编译成`.psd`文件. 于是, 弄了个python文件, 并且导入, 发现`pyright`并没有报错, 说明存在对应的模块, 并且`pyright`能够识别, 可是后来发现, 运行就报错.  <br>
&emsp;&emsp;为什么呢? 整体上来看, 都没问题啊, `C`端编译正常, `pyright`也没有报错, 能正确识别这个函数, 怎么运行就出问题呢? 没办法, 只能问`ai`. 了解到, 除了`.psd`文件, 可能会有`.dll`相关的依附动态库. 我找了一下, 发现确实有一起, 于是抱着期望, 将这个`.dll`文件放到同目录下运行, 还是有问题. 此时我觉得, 是不是将`.dll`相关内容, 集成到`.psd`文件中, 就可以啊? 于是将`.dll`文件又集成了一下, 发现还是无法导入.问了问`ai`, 还是不行. 然后呢, 我就看视频了解, 发现`macos`端, 操作跟我一样啊, 怎么就能正常导入呢? 我`windows`端怎么不行呢? 又去`pybind11`官网看了看, 也没看出个所以然来, 示例代码跟`ai`给我的差不多, 理论上应该能导入啊?  <br>
&emsp;&emsp;昨天晚上弄到`11:40`多吧, 不甘心地睡觉了. 昨天晚上也一直在弄这个, 就是没法成功导入. 可是睡觉之前, 我看了一个视频, 说, 用`visual studio2022`编译就行, 在`pybind11`官网上也看到了, 用`visual studio`编译, 但是当时太过混乱, 没多想, 也不愿意想, 于是去睡觉了. 第二天呢, 也就是今天, 上午一上午的课. 课上无聊, 我又复盘昨天的失利. 想了想, 应该是编译的问题. 我是用的`gcc/g++`编译器, 可能就是因为编译的问题, 导致不可行. 于是, 便问了问`ai`, `windows`端, 编译成`.psd`相关文件的话, 是不是必须要用`MSVC`(也就是`visual studio`)编译器, 它说是的, 其它编译器(`gcc/g++`等), 会存在问题.  <br>
&emsp;&emsp;我直接震惊了. 昨天的时候怎么不说限制编译器呢, 我问了才说...幸好看视频, 看文档了解了一下, 要不然, 一直被这个问题困扰. 所以, 今天上午的时候, 虽然两节课, 我已经大体构建了思路, 回去先下一个`MSVC`等工具, 然后再重新编译测试一下. 也考虑了`C`端的整体架构是有问题的, 我是在`core`核心数据结构代码同目录下, 创建了一个`bindings`文件, 内部又有`python java lua`等代码对应的编译包. 这是有问题的. 数据结构部分代码, 应该单独出来, 然后, 我想绑定到`python`端, 创建`python`相关项目目录, 将数据结构的项目整体放到`python`项目中来, 然后写对应的`.txt`编译文件, 这样才对. 等写`java`的时候, 也是同样的道理.  否则, 按照我之前的思想, 代码杂糅太厉害了, 而且需要一直修改`.txt`文件, 这是非常忌讳的.  <br>
&emsp;&emsp;回去之后, 先下载相关配套工具, 可是有很多东西, 比如需要学习`cl`终端的使用方式. 另外, 还需要重新修改数据结构端的代码, 以及`CMakeLists.txt`代码. 由于`CMakeLists.txt`的语法还不是很熟悉, 所以还是比较头疼的(也不是很头痛的那种, 主要是存在多种编译情况, 每种编译情况代码还不一样, 总是害怕忘记). 对了, 还有`powershell`的脚本代码, 也是写好了, 都需要重新修改了. 此时, 差不多到了`1:40`, 觉得太过混乱了, 有太多的东西要重新弄了. 虽然有了应对方案, 但还是想上床休息休息. 最后, 在床上睡了一个半小时, 又看了一个小时的手机, 并且思考了三十分钟(其实没这么多), 想明白, 准备下床搞搞(此时到了`4:40`).  <br>
&emsp;&emsp;最后呢, 想了想, 还是写写这个文档记录一下吧, 于是写到了现在`22:12`(当然, 不是一直写, 中间去吃了顿饭, 并且晚上还是操作系统实验课).  <br>

### 反思

&emsp;&emsp;今天写这个的时候, 觉得, 用来当做数据库的`ai`使用分析还是不错的, 所以里面也加入了使用`ai`的一些点, 虽然不是针对数据库层面的, 但是宏观`ai`使用的描述, 还是比较详细的(比如说, 什么情形下, 使用`ai`, 虽然没有贴详细问答情况, 但知道什么情况下回去问`ai`, 我觉得也是足够的). 另外, 这写内容全是自己手写, 没有任何`ai`痕迹的真实报告, 而且是真情流露, 参考价值极大(至少我是这样认为的) 下面再说说具体的反思吧. 会结合多方面的, 而不是仅限于某点.  <br>
- 我觉得, 我是来拓展视野的. 如果我知道的足够的多, 范围面很广的话, 那么, 我只需要详细地问一下`ai`某项领域的实现细节, 问题几乎就能解决. 但是, 如果我是纯小白, 不知道从`0`怎么弄的话, 很难一次性(注意, 这里是一次性)向`ai`问出解决答案来, 需要能比较, 分析, 判别的能力. 
- 在`os`层面, `ai`并没有直接解决我的问题, 反而是第三条, 解决了我的问题. 一开始的话, `ai`确实浪费了些时间, 但是我也了解了些东西(比如工控主机等). 但是, 跟随他人学习`os`的时候, 深入理解方面, 全是借助`ai`. 
- `C`代码移植`python`层面, `ai`最后也没有解决我的问题. 不过, 它其实解决了我大部分的问题(代码没有问题, 相关库的选择, 给我了很多的参考), 最终只是差在了编译器不对. 最后从视频, 文档中了解到, 需要`MSVC`编译器编译才行.  
- 昨天晚上一直导入不进去, 心情十分低落, 但是今天上午想明白后, 又有了动力. 不过中午下载相关依赖后, 又被许多问题压在身上, 选择了先去休息休息. 最后又写了这个总结.
- 最后, 这里再分析一下`ai`的使用吧. 
    - 对于理解层面的东西, 毫无疑问, `ai`是最有用的, 比课本有用, 能增强心理表征. 有了足够多的理解后, 再去看课本, 很有帮助(比如, 单纯看`linux`内核的书的时候, 只能理解一小部分. 通过`ai`, 有了一定的理解, 并结合自己写了一些`os`后, 再去看书, 能看懂很多了. 但是, 没有前面的前提, 单纯地看书, 几乎毫无用处.).
    - 语言语法的学习, 命令行的使用, 软件快捷键等的学习 `ai`也是最有用的. 这些东西比较固定化, 而且能迅速得到反馈, 对就是对, 错就是错. 绝大部分情况下, `ai`给的都是对的.
    - 自己认知之外, 完全不了解的东西, 慎重选择`ai`, 它大概率会给出解决方案, 一定情况下, 可能是对的, 但是如果是错的, 可能会陷入循环之中, 一直错下去. 此时视频, 文档是最好的解决方案. 所以, 这个时候, 使用`ai`, 不要问它解决方案, 而是将具体的问题问它, 看它如何解决. 对于给出的方案, 再问它是什么, 千万不要直接`copy`代码测试, 先知道它说的是什么东西, 干什么用的, 看看逻辑是否正确, 再向它要到参考网址, 仔细看看对应文档. 这样比重复地问`ai`强很多.
    - 当然, 最好能找到教学视频, 这样就会符合第三条, 比较类似上面`os`时的情况. 
    - 所以, 感觉上复杂的项目/问题, `ai`不是首选, 文档, 视频, 第三条, 是最优选择. 理解层面, 固定语法层面, `ai`是首选. 
> 今天已经`22:47`了, 就不弄代码移植的那个了, 明天再弄吧. 关于那个东西, 只能依赖`ai`. 先弄个最简单的`C`和`python`代码, 然后编译, 看看能否导入, 能导入的话, 再去写写数据结构, 并且写写`CMakeLists.txt`, 看看编译链是否有问题. 假如一开始导入失败的话, 我会怎么办呢? 查找文档, 了解一下实现细节. 不过, 理论上一定可行, 如果不可行的话, 那我也确实是没有办法了. 

### 01反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.6 10:37  

&emsp;&emsp;我服了, 今天早上起来, 感觉搞了有`15 min`吗, 就解决了...我还以为, 仍要搞上半天呢, 原来不用...无语. 如果是昨天混乱的情形, 还不知道搞多久呢. 下面就记录一下, 我如何问的`gpt`吧.<br>
- 第一条
我现在想用pybind11, 编译C++, 然后在python端调用.  <br>
注意, 我用的是MSVC编译器(Tools 命令行工具), 没有visal stdio,  <br>
请告诉我详细地pybind11 绑定步骤.  <br>
最简单的就行.  <br>
不要有其它额外操作, 谢谢  <br>
- 第二条
{  <br>
    "venv": "AI",  <br>
    "venvPath":"E:/Anaconda3/envs"  <br>
}  <br>
这是我的虚拟环境目录  <br>
E:\Anaconda3\envs\AI\libs 这是libs  <br>
E:\Anaconda3\envs\AI\include  <br>
这是include  <br>
我的python是3.11版本的  <br>
"F:\MSVC\Tools\Common7\Tools\VsDevCmd.bat" -arch=x64  <br>
这是我的MSVC路径  <br>
F:\0github\Learning-Computers\programming-language\python  <br>
这是项目路径  <br>
请集合上面路径, 详细说说  <br>
- 第三条
F:\0github\Learning-Computers\programming-language\python\pybind11  <br>
这是我的pybind11路径  <br>

---
&emsp;&emsp;问了第一条后, 我发现它不知道具体路径, 我就将对应路径给它, 然后问了第二条. 之后我发现, 它假设我`pip`安装的`pybind11`, 但其实我是自己下载的, 这样它就不知道我的路径, 所以又问了第三条, 然后, 按照它的代码和命令行, 成功实现了我想要的效果. `15 min`搞定.  <br>
&emsp;&emsp;当然, 这里使用`ai`, 是为了了解/熟悉一下流程. 因为之前失利过, 所以这次只需要最最最简单的方式测试即可, 明白基本的操作流程后, 便可以自定义`diy`了. `easy`, 散会!<br>

---
&emsp;&emsp;算了, 再来总结一下吧.  <br>
- `ai`怎么样, 还是要看用的人. 假如基本流程我很熟悉, 就是代码/命令行有些记不住, 那么, 我可以把很多关键信息, 有用信息提供给它, 只是需要它给我的代码/命令行即可.
- 可是, 如果我是真的纯小白, 不熟悉流程, 没有基本思想, 怎么能向`ai`问出好的问题呢? 相反, 如果在我很懂的基础上, 我能问出个花来. 不过, 我都很懂了, 肯定也不会选择问`ai`.
- 我的需求, 其实非常简单, `python`调用`C/C++`. 如果直接去问, 它会给出很多选项, 选哪一个呢? 我的要求是快, 难点, 复杂点也无所谓. 这时, 选出来了目标库(`pybind11`), 再去问它如何实现. 可是, 用了`n`种方法, 流程层面, 都没问题, 可就是调用阶段, 总会错误. 什么问题呢? 不知道. 继续问`ai`, 也问不出来了. 于是看视频, 查资料, 发现是编译器的问题. 于是, 问了关键性问题, `python`导入动态库, 编译器是不是有限制? 果真, 我知道了, 只能用`MSVC`编译器. 我一开始怎么不问编译器是否有要求呢? 因为我压根不知道这个点, 默认`gcc/g++`就可行, 但实际上呢, 并不行. 
- 这个问题, 很早就思考问过`ai`, 我就知道`.dll`动态库, 可以灵活导入. 脑海里想的是, 只要成功编译成`.dll`动态库就行了, 其它的就很轻松了. 可是真的轻松吗? 简单倒是挺简单的, 但是坑却都踩了一遍.
- 其它的总结, 之前也都说过了, 我今天也就是按着流程走了一遍. 不多说什么.额, 结束.

### 再反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.08 17:59  

&emsp;&emsp;为什么是再反馈呢? 这个文档主要是记录难受时/毫无斗志时的状况与解决方案. 而写这个时, 并没有出现什么消极的心理状况(可能有, 哈哈), 主题也与上述基本一致, 所以是再反馈. 罗列一下吧, 并且将问题说出来.<br>

- 上面的内容, 有关键的五条, 列举如下.
    - 良好的编写代码/运行代码的环境.
    - 良好的可视化的反馈.
    - 可参考的开源代码/书籍.
    - 兴趣驱动.
    - 问题驱动.
- 最终解决我`os`问题的是第三条, 所以默认为第三条很重要. 第三条确实重要, 但是让我搞不清主次了. 
    - 问题其实还是在`cmake`上. 上面说了这么多, `cmake`对于`C/C++`开发, 确实是很重要. 所以, 后面我就又打算专门去学习`cmake`去. 
    - 此时, 跳过了`ai`, 直接先找书, 又去咸鱼上找项目. 果然, 找到一个.
    - 可是一打开发现, 全是视频, 最后有些`cmake`的代码. 
    - 标题起的很好, 内容也很丰富, 什么都有, 学会了一定很好. 可是, 真的适合我吗?
        - `cmake`困住我的点是什么呢? 
            - `target`, `library`, 等等, 表意不清.
            - 变量, 字符串, 路径名, 分不清.
            - 逻辑, 层次引用关系, 分不清
        - `cmake`跟传统的高级语言还不同, 不像其它语言那样容易区分.
        - 虽然跟着`ai`, 能写出来, 但是, 还是会非常混乱的, 虽然能正常编译, 可是看到那些函数名, 不知道作用, 比较茫然.
        - 视频的问题是什么? 
            - 并没有直接解决我的困惑, 前面简单的时候好些, 后面复杂的时候, 还是会混乱(可能因为没认真看的原因, 但确实讲的不好).
            - 三端一同讲解(`win`, `linus`, `macos`), 不是说不好, 但是我是不愿意看的
            - 给的项目代码, 不是完全版, 跟视频中讲的无法对比上(可能有三端的代码, 但是很明显, 我拿的不是`win`端的代码. 也怪不了什么, 毕竟闲鱼`0.01`薅的)
        - 后来, 我才明白, 我还是不适合看视频学习. 被上面的`os`, 蒙住了双眼. 
            - 仔细回想一下, 我看视频学习, 只有嵌入式, `os`, 这种比较偏向底层的(应付期末考试的视频学习不算, 那种是被动学习, 这里说的是主动学习). 当然, 还有数学的一些深入理解的视频, 有疑惑的时候, 才会搜搜看看. 
            - 像这种`cmake`, 看视频学, 根本不可能的, 几十个小时呢. 
            - 虽然说, 学会了, 肯定很美好, 但是, 对我自己来说, 看完一遍视频, 根本不可能懂的. 所以不适合我.
        - 想了想, `cmake`可能还是缺少可视化, 当时不知道直接输出测试的. 
- 经历了上面的之后, 我打算, 还是要自己主动创造, 动手从零慢慢写. 理解层面的东西, 还是要靠`ai`的, 从视频中对我而言, 肯定无法获取到什么的. 
    - 我主要是想自己写. 但是呢, 终端的`cmake`没有补全, 那些函数什么的, 根本记不住, 只能对着写.
    - 能带着自己的思想写, 想干什么就干什么, 不受限于其它, 这是我的目的. 
    - 最后呢, 也确实是实现了. `cmake`语言形成了自己的一套规范, 能够很好地区分出来什么是什么, 而不仅是一串看起来都相同的东西. (这里说起来容易, 但是做的时候, 也很不容易. 不过好在都区分了)
- `cmake`弄好后, 我又想着将`C++`代码弄到`python`中去了. 不过又走了远路.
    - 之前弄的, 就仅仅在`bind.cpp`中进行绑定. 我期望的是能灵活绑定, 灵活导包, 而不是十分受限地进行操作.
    - 这里涉及到很多难点. 当时其实都不知道, 但因为走了很多的远路, 所以也了解了很多, 基本的原理也都明确了.
    - 在此之上呢, 我就打算尝试复杂导包, 并且写好`cmakelists`. 但是呢, 问题还是发生了, 总是有错误. 改来改去, 错误依旧在. 最后实在没办在了, 只好上床休息一会. 等着从床上下来的时候, 已经有灵感了, 就是跨度太大, 结合基本的, 一步一步慢慢添加就好, 不用一口吃成个胖子. 
    - 上面说了, `cmake`有很多函数, 背过不可能的, 所以, 我还是对比着写的. 最后写完的时候, 也终于发现了一个极有可能的错误点, 就是在添加库的时候, 应该先添加`core`, 后添加`pybind11`, 可是我这两个写反了.
    - 测试了一下, 果然是.
- 上面说了很多, 但只是大体描述了一下. 真正修改/`debug`/理解/一直编译不通过时的心情, 很难描述出来. 最后呢, 是能编译过, 但是却发现`python`端导包, 一直有问题. 不过最后问题实际上, 也很简单, 这又说明了什么呢?
> `cmake`, 对我来说, 肯定是非常重要的, 专门学习一下, 是必须的. 虽然走了很多远路, 但是对于理解层面, 能够起到很多的帮助. 现在了, 能够精细化地自己编写`cmake`了, 而不受限于`ai`. 虽然, 精细度还不够高, 但目前能解决我大部分的困惑足矣. 等后续, 需要进一步深入`cmake`的话, 再去了解即可. 其实就跟`vim`一样, 刚开始的时候, `vim`操作不熟练, 脚本自己也不会配置, 困难点多了去了. 但是练习两个月后, 再此基础上, 重新配置的话, 手拿把掐. `cmake`也是刚开始弄, 一上来就想全学会? 根本不可能的.

### 再再反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.09 11:51

&emsp;&emsp;昨天凌晨一点多, 又买了好几本书, 两本`xml`相关的, 一本计算机图形学, 一本`cmake`相关的, 一本`vulkan`相关的(只有这个是一手的, 上面其他的是二手的, 比较便宜). 感觉从大二到大三以来, 所学的一切, 都是在为开发这个软件而准备着, 有意无意中, 很多东西都是相通的. 其它的先不说, 就这几天的`cmake`, 就很有必要. 本来打算后续要`c++`开发, `cmake`必不可少, 所以了解一下. 后续用`pybind11`, 需要用到`cmake`, 底层`os`, 也跟`cmake`有关. 直到今天看了`vulkan`的电子书, 发现里面也是用`cmake`构建的. 一开始学`cmake`的时候, 并没有考虑这么多, 只觉得以后可能会用到, 但没想到, 确实很常用. 另外, 还有`xml`. 之前看面向对象设计的书中, 有提到过`java`里面的相关`xml`的包, 但是当时不知道`xml`是什么. 后续, 又疑惑, 为什么有的软件能自定义后缀名(之前弄`pr`的时候, 会有`pr`相关的工程文件, `adobe`其它的文件都会有专有的后缀名. `keil5`也是), 通过`vim`打开, 发现是纯文本, 复制给`ai`, 了解了自定义后缀名的原理, 也知道了`xml`是什么. 嗯, 那我也就知道了, `xml`也是需要学的. 昨天上`web`的时候, 又听到老师说, 数据库跟高级语言间, 可以通过`xml`交互, 那确实, `xml`需要专门了解一下了, 于是又买了书, 打算看看. 等等等等还有很多, 也就不细说了.  <br>
&emsp;&emsp;昨天发现, 通过`C`写的代码, 给`Python`调用, 必须通过`C++`来一层中间调度(`pybind11`)绑定. 也没当回事, 打算就是专门地写一层`C++`就好, 其它的也不用过多地考虑. 今天上午写的时候, 发现, 写的这一层中间层, 目前似乎专门为`python`准备的. 可是这一层, 完全可以剖离出来. 什么意思呢? 就是底层`C`写好, 中间层`C++`封装调用. 这样来看, 底层其实就只有`C`, `C++`, `python`只能通过`C++`绑定, 那么我只调用`C++`即可. 其它语言呢, 可以调用`C`的话, 就直接调用`C`, 能调用`C++`, 就直接调用`C++`即可, 其它的也不用管了. 模块化, 需要足够地清晰.  <br>
&emsp;&emsp;刚才又想了想, 那我为什么不直接编译成动态库, 这样每次只需要携带一个动态库就行, `python`端只需要写一个绑定代码, 然后链接这个动态库即可. 这其实就涉及到`cmake`的高级用法了. 可以灵活性地编译, 而不受外界影响. 现在我知道以前的那个视频里有相关的描述, 但是也不太想看, 因为肯定说的很复杂, 我想了解的那个点, 很难直接找到. 所以, 还是结合`ai`, 了解一下. 另外, 也不要在当前的复杂环境中交互, 完全独立出去, 剖析成最简单的部分即可.  <br>
&emsp;&emsp;一直这么重复地弄, 有意义吗? 肯定有. 表面上是在弄`python`如何调用`C/C++`, 实际上是在学习`cmake`. 搞明白上面说的那个, 有更进一步了. 这样后续可以灵活编译, 更加清晰明朗. 固然, 我也可以一次性写完, 全部编译成静态文件, 但感觉实际中肯定不是这么干的. 加强灵活性是必然的.  <br>

### 再再再反馈
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.10 15:12  

&emsp;&emsp;把`cmake`几乎搞明白了. 当然, 还有很多东西, 比如说, 动态链没怎么弄, 但觉得静态链搞明白了, 动态的就差不多了. 另外还有`.cmake`自定义配置相关的东西, 目前来看, 没太有必要, 自动生成就可以了. 总之, 目前这个状态就比较满意.  <br>
&emsp;&emsp;昨天跟一个算法很好的人聊了聊天, 想向他取取经, 但结果还是比较让我失望的, 这里细节就不说了. 我自己呢, 很愿意学习底层的东西, 这样的话, 写代码能够精确控制. 所以整体理念, 就是向`ai`学习, 学的差不多后, 可以自己主动编写, 而不是仍旧依靠`ai`. 之前看了个斯诺克视频, 里面有句形容火箭的话, 是"母球所到之处, 即是心中所想". 这很符合我学习编程的思想, 每一行代码, 都能达到自己心目中想要的效果, 每一个错误, 都在我的预期范围内. 但是`ai`写的代码, 很难控制. 如果想要添加些东西, 或者删除些东西, 几乎无法添加. 当然, 我们可以仍旧扔给`ai`, 让它修改一下. 但我觉得, 这是那些不会编程的人弄的, 身为计算机的学习者, 应该能够达到精细化控制的效果, 而不是被`ai`掌控. 为什么渲染引擎我选择学习`vulkan`, 而不是`opengl`呢? 就是`vulkan`能够精细化地控制. 在我看来, 并不会因为难而选择放弃, 而是因为能够精确控制, 我才选择学习. 当然, 网上他们说`vulkan`怎么怎么难学, 我觉得, 还是缺少其它知识的补充. 在我具备很多额外等东西后(尤其是底层`os`运作原理), 其实也就没有那么困难了. <br>
&emsp;&emsp;回过头来再看看, `cmake`是否难学呢? 我觉得困难点还是变量命名不清晰, 代码多了容易乱. 所以, 我都会选在用`${}`变量显式地标注出来, 能够让我很容易地看明白什么意思. 从专门想学`cmake`, 到现在, 在实践中去理解, 用了差不多三天的时间吧. 之前买的那个视频, 二三十个小时, 专门学的话, 肯定不止三天. 我的目的是快速掌握, 快速理解, 不是细嚼慢咽地学习, 太拖拉了.  <br>
&emsp;&emsp;以前很害怕学习新的东西, 总想安于现状, 所以很多东西都会选择通过`ai`快速解决. `cmake`或许就是这样的. `ai`虽然能快速给我大差不差的`cmake`代码, 但是, 我自己几乎无法修改, 想要修改只能再喂给`ai`, 也就是我上面说的. 不过专门学习一下, 自己抽象模拟项目的话, 也就`3`天的时间, 就能掌握大部分内容. 嵌入式的相关东西也是, 我就用了一个月的时间, 明白了很多很多, 自己也能写代码, 主动控制, 这是我一开始没有想到的事(当然, 这期间我付出了很多, 其实也都是向`ai`学习的, 底层原理知识, 靠`ai`理解的. 后面我自己写了个`c++`库, 又明白了`c++`在裸机嵌入式的应用.虽然设计的不太好, 但是也确实锻炼了代码能力). 所以说, 学习新东西, 并没有多么困难, 享受学习的这个过程. 从不理解->理解, 真的很有意思, 当然, 有意思的是理解时的过程, 并不是理解后的应用. 在理解很多东西的前提下呢, 学习新的东西的速度会更快.  <br>

---

&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025.12.10 21:08  

&emsp;&emsp;这次是想写点数据结构与算法的东西. 之前数据结构与算法, 确实没怎么好好学, 这几天打算重写一下数据结构, 上面做的一切, 其实都是在准备着(项目的抽象模拟, `C`端写的数据结构更具备通用性). 准备完之后呢, 还是要重新回归写数据结构的.  <br>
&emsp;&emsp;上面也说了, 我学习编程, 是为了能精细化地控制, 达到"母球所到之处, 即是心中所想"的境界. 数据结构与算法也是如此. 那么如何做到呢?  <br>
&emsp;&emsp;一开始尝试写了写`SqList`, 发现还是按照书上的内容写的, 缺乏个人思考, 说白了, 没有任何效果. 后来呢, 我就设想, 假如, 我将我的`SqList`移植到`python`端, 会存在什么效果? 课本上, 只有线性表的初始化, 销毁, 清空, 插入, 删除, 遍历这些内容. 其中, 插入的话, 只是一个一个的插入. 如果`python`端, 我传入一个列表对象, 单单就上面几种方法, 肯定是不行的. 如果在`python`端循环插入, 速度反而更慢(每插入一次, 就需要调用一次, 效率更差). 此时我知道, 可以添加一个方法, 能够以数组(指针)的形式存储.  <br>
&emsp;&emsp;后续在具体实现`ListInsert_Sq`的时候, 还是缺少常规性的思考. 这些东西呢, 在暑假的时候分析过, 但是到现在呢, 也都忘了. 什么原因呢? 缺乏系统性的学习. 当时可能只是为了解释而去解释, 没有太大意义, 时间一长, 理解可能就变了. 此时我有一些问题, 比如:课本上`position`从`1`开始的, 而我更习惯从`0`开始, `if`语句判断, 存在两种可能(< > 或者<= >=), 选择哪一种呢? 同理, `for`循环也是, 这种多向的选择, 容易造成我理解性的误差(什么时候带等号, 什么时候不带呢? 如果用哪种都行的话, 是不是我固定成一种就可以呢?). 带着这种困惑, 我问了`ai`. `ai`直接完美地解决了我的困惑. 下面是我添加的注释(英文的, 因为写中文, 编译时可能会有警告, 为了避免警告, 就写了英文的)  <br>
~~~C
/* 
    is position legal?
    realloc?
    position start at 0 or 1? if flag == 0 -> start at 0 else start at 1
    updata capacity?

    understand operation space
        for array, we use [0, n), which is 0-based.
        so, to solve this problem, the position parameter also use 0-based.
        the position parameter's operation space is [0, L->size]( L->base is [0, L->size) )
        so, the illegal operation space for position parameter is (0, L->size) . easily.
        for k, its operation space is [0, L->size) ( [0, L->size - 1] to fit position parameter' space operation( [0, L->size] ) )
        so, if k == position, we'll insert. if k > position, we'll not insert, its illegal.
        based this, we know the for loop condition , which is (k = L->size - 1; k >= position; k--)
    the for loop condition we've got, is based on the position operation space and the k(L->base) operation space.
*/
~~~
&emsp;&emsp;这样呢, 我就有了自己的一种思考方式. 在遇到类似问题时, 可以去思考操作空间, 基于此, 来判断对应条件, 这样也就避免了使用`ai`, 或者是直接去抄课本.  有了自己的思考, 是我能做精细化编程的前提. 算法, 有灵活性的算法, 有思想的算法, 肯定是带着自己思考去解决的, 而不是靠`ai`. `ai`只是提供给我各种思考方式, 让我去理解, 并产生自己的理解, 从而能够独立地思考.  <br>

## 2025/12/22
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-22 18:07:43  
&emsp;&emsp;注意, 下面的内容呢, 并不是一口气写下来的, 所以读起来会有断断续续的感觉, 缺少连贯性. 可能在说着`A`, 下面突然越到了`B`. 不要在意, 也不是逻辑问题. <br>

### 面向对象
- 前两天吧, 又被面向对象设计与分析搞得比较难受. 设计类问题, 跟编程学习有很大的不同, 所以说上面的内容很难移植到设计上面来. 我自己喜欢底层高度抽象化设计, 但是呢, 缺少良好的建模思路. 写倒是能写出来, 但是总会多方面分析是否合理, 或者结合`ai`, 看看有没有更好的解决方案.  
- 面向对象设计类的书也有, 但这些东西肯定不是看看书就能明白的, 必须结合实践. `GOF`有`23`种设计模式, 总是想着集大成, 但是确实是非常非常困难. 按照以往的思路呢, 应该就是先简单实现一下, 看看效果如何, 但是前两天并没有这么干.  
- 分析一下原因所在吧. 首先, 我一上来看的是工厂模式, 抽象工厂模式, 自己的实际问题是在`cpu`内部建模问题. 刚开始感觉可以套这个模式, 虽然能写出来, 却总感觉十分奇怪. 于是就陷在这里了:后面明明还有其它`22`种模式, 却只想先搞明白这种, 并且应用在它不一定适合的地方. 另外, 以为自己懂了抽象工厂模式, 但现在来看的话, 实际上并不懂.  
- 后面就找视频啊, `github`上找例子啊, 等等. 最终还是在`github`上找到了一个比较好的例子, 日本老哥写的. 确实不错. 我自己先整体改了改, 又按照自己的思想写了写, 才比较彻底地明白了抽象工厂模式. 它的例子几乎都是`web`开发层面的, 比较贴合实际生活, 而我自己呢, 更偏向于底层, 需要高度抽象化思维. 但是目前来看, 仍不具备这种思维, 还是按照传统的思想来考虑的.  
- 根据个人学习哲学来看, 这些都是无所谓的, 关键还是要多应用的. 但是从`web`日常思维抽象->底层高度抽象思维, 需要一定的转变过程, 不是说看看几个例子就会了的那种, 必然需要平时更多的底层高度抽象模式实践应用.  
- 现在来看呢, 还是先将`GOF`的`23`种设计模式学完再说, 应用层面还是以`web`为主. 等后续对设计模式有了一定理解后, 再进行思维的转变:像底层高度抽象思维的转变, 这样可能会好很多.  
- 当然, `23`种设计模式, 一口气学完肯定不现实的, 慢慢地学就行. 比如一天学一个, 但是一定要及时巩固复习. 当然, 这种复习肯定不是说去背某个模式, 意义不是很大, 我觉得可以换一个实际应用场景, 再自己建模思考, 并且评价这个模式在这个应用场景的效果如何. 不必非得用代码实现, 自己脑子里有一个模型就足够了.  
- 另外, 我觉得, 对于底层层面的建模, 并不是说会了建模就一定可以, 底层的相关知识也需要有自己一定的理解, 否则二者不在同一水平面上, 即使建模水平再高, 缺乏底层相关知识, 也是无法设计好的.  
- 对了, 再说另外一个问题. 本来还是想写`os`的, 但是为了更好地抽象模拟`cpu`内部运行态, 经过综合考虑, 打算用`python`模拟. 这是我最初的需求. 后续发现自己并不能很好地建模, 虽然写完了, 也能运行, 但是整体结构我并不满意. 后续又看了`ai`的设计, 其实整体设计思路非常好, 而且能直接拿来用. 但是我并不喜欢这样, 我想自己能独自设计. 这就有了上面的重新分析面向对象设计, 并思考对应模式的原因. 可是我最初的目的, 仅仅是做一个模拟, 本身还是要学习`os`的, 现在却又转向去学另一个东西了. 我不知道这么做是否正确, 但是随着"工具"越来越多, 效率/速率会逐步上升. 目标是学`A`, 但是兜兜转转没有学`A`, 转而去学`B`去了. 这可以是当前情况的简述了. 看`B`的难易程度吧, 简单的话, 学会`B`再弄`A`, 无可厚非. 难的话, 只能拉长战线, 间接性学`B`, 主要目标还是学`A`, 这是比较好的解决方案. 当下情况就是后者. 
- 但是以我的个性, 非得弄懂才罢休, 哈哈. 目前也正在尝试着转换这一思想. 
- 刚才看了之前有的一本电子书, 《面向对象是怎样工作的》. 刚看完第三章吧, 最关键内容还没有看到, 但是总感觉似乎能解决我的问题. 不过我的问题是什么呢? 很难意会. 尤其是设计类的这些问题, 很难讲明白. 
- 想了想, 没有好的参考. 我目前分析过的库的话, 是`python`的`manim`库, 面向用户层面的, 不难理解, 但是底层实现层面, 感觉十分混乱, 不知从何入手. 另一个是`C`的嵌入式的标准库. 但是这是非面向对象语言, 更多的是函数式编程, 有一定的面向对象角度学习的参考价值, 但是并不是很大. 书上的例子又过于虚化, 很容易理解, 但是很难真实理解. 想了想, 还是因为缺少实际应用. 后续怎么办呢? 还是先将基本设计模式学完, 再谈下一步吧. 慢慢来, 不着急. 
- 太急了. 拉长战线吧. 一天学一个模式, 虽然很容易理解, 但是其实没啥用, 理解了不代表会用. 多拿出来时间思考模式应用场景比较好, 这样会建立更深入的理解. 

&emsp;&emsp;**"特别是像`OOP`这样有趣的结构, 人们一旦对其有所了解, 无论如何都想立即使用,  这也是人之常情. 如果是出于兴趣而编写的程序, 这样做倒没有什么关系, 但如果是实际工作中使用的程序, 这样就会很麻烦. 切记, 我们的目的是编写出高质量/易于维护和可重用的程序, 面向对象只是实现该目的的一个手段而已."**<br>
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-23 16:10:28  

- 上面这句话是《面向对象是怎样工作的》书中的一段话, 确实说到我心坎里去了. 
    - 刚开始学`c++`的时候, 懵懂时期, 也没想怎么学, 不过我知道面向对象很重要. 
    - 后面在`python`中, 学习使用`manim`, 整体上来看, 其实是面向过程的(抽象部分被封装好了), 但是我期望额外拓展, 认识到了面向对象理解的不足, 疯狂弥补知识, 并在`manim`中实际应用, 取得了不错的效果. 回过头来看的话, 也没什么, 底层最难的部分, 别人封装好了, 应用层只是调用而已. 另外, 在别人封装好的基础上再封装, 没什么难度了, 按照别人的思想来就行. 但是有一说一, `manim`确实给我带来了极大的语言学习理解的能力(不止是面向对象方面的).
    - 后续在`java`里, 进一步拓展落实. 思考一下呢, 面向对象部分涉及似乎并不多, 但是`java`作为强面向对象类的语言, 还是有一定帮助的. 这段时间做了不少的题目, 几乎都是带着脑子自己写的, 没用过`ai`. 
    - 到此呢, 是整个学习过程, 概念都懂, 有一定的应用(`manim`), 但是缺少具体的实际应用. 对面向对象有了宏观上的理解, 现在看来, 当时的理解并不深入, 而当时觉得呢, 自己已经差不多了. 
    - 后续, 是在嵌入式中具体实践应用面向对象编程. 主要原因在嵌入式文档中也说得很明确了, 单纯地靠抄写别人的`C`代码, 很乏味, 而且没有长进. 而面向对象呢, 是我的兴趣所在(正如上面书中所说), 采用面向对象对嵌入式标准库进行封装, 可以让我带着脑子, 靠自己的思想进行编程, 而且能结合`ai`, 对硬件有更深的理解. 
    - 问题也是在这个时候发现的. 我尝试封装, 发现对象的生命周期并不相同. 比如, 我在某个类内部, 实例化`led`的话, 这个类的生命周期结束后, `led`的生命周期是否也结束呢? 我当时确实是不知道的, 因为在`manim`中, 没有遇到类似的问题, 在`c++`和`java`中, 都是做题抽象模拟的. 可是到了实际中来, 又迷茫了. 
    - 所以我选择了回避这个问题. 后续呢, 通过继承封装, 比如, `usart`串口, 必须跟`tim`相结合, 我采用了继承的方案. 现在来看, 根本就不合理. 我思考的是串口总是会用到`tim`, 但是呢, 从面向对象角度来看, 二者并不是同一类事物, 怎么可能继承呢? 还是应该采用组合的方案(我觉得受到了`manim`的影响).但是呢, 上面说了, 回避这个问题(组合问题, 生命周期相关的问题), 所以没有这么做, 也不敢这么做(其实还是怕麻烦, 需要反复测试). 现在想想, 还是面向对象知识的匮乏, 导致在这里不能很好的建模. 或者说, 根本就没有建模思想. 
    - 这里, 是我发现问题所在. 当时更多的并不是思考嵌入式编码了, 思考的其实还是面向对象, 如何合理地构建. 而且后面随着代码的增多, 越来越复杂, 我也不太想去改了. 最后综合性实验, 选择了`100`分的题目, 靠着这个小库做完的. 跟老师讲的时候呢, 解释了四十多分钟. 当时也产生了疑惑, 面向对象到底是否有必要呢? 
    - 这期间呢, 在人工智能实验中, 需要用到`matlab`, 一开始也并不怎么想写实现代码, 不过当我知道它是可面向对象的时候, 我会选择通过面向对象的方式进行编写, 正好符合上面"兴趣编写程序".
    - 这期间还有另一个问题, 就是`neovim`配置. `lua`语言虽然不是面向对象的, 但是提供了面向对象的机制. 为了理解, 我将原来的普通方式编写, 全部换成了面向对象式的. 后面发现了问题, 就是复杂化了. 而且看别人写的代码, 没有这么写的. 忘了什么原因了, 导致我又用普通方式重新编写了一下, 而不是采用面向对象的方式编写了. 
    - 至此, 我明白了, 能用面向对象编写代码, 不代表真正理解面向对象. 我们更多地, 其实是使用别人通过面向对象封装好的代码, 而会使用不等于自己会封装. 
    - 上面的经历, 跟书中的话太像了. 为了弥补自己的不足, 买了些面向对象设计类的书, 但是目前来看似乎没什么用. 怎么切实真实地理解面向对象呢? 拭目以待吧. 
- 写的太好了, 刚才又往后读了一章. 
    - 详细解释了`oop`底层调用机理. 虽然各个知识点也都知道, 但是并没有和`oop`联系起来. 这本书做到了这点, 感觉不错. 
    - 之前写`java`的时候, 都会`new`一个对象, 不过原理并不清楚, 只是一味地`new`. 在`c++`, 不论是刚学, 还是之后的嵌入式, 也只是单纯地实例化对象, 没有用到`new`. `python`更不用多说, 也没遇到过. 抽象基类是在《`python`面向对象编程》中了解到的, 但其实当时根本看不懂. 
    - 另外, 还有多态, 在`c++`中学过, 但是也只是知道这么做, 并没有个人的理解. 后续在`java`中, 会发现, `new`的对象, 跟其类名并不相符, 不知道什么原因, 不过当时也没打算搞懂(其实还是在某些工具使用中遇到的, 并不影响做题).
    - 真正的理解, 也就是前两天. 上面说过, 从`github`中找到了一个日本老哥写的面向对象`23`中设计模式的`c++`代码, 里面用的是现代`c++`写的, 看不懂什么意思. 仔细询问`ai`过后, 发现这里其实就是使用的指针, `new`一个对象而已, 好处是自动垃圾回收, 不用手动删除. 不过, 改成`new`写法的话, 跟`java`好像啊! 我明白了, `c++`这里是在堆区实例化对象, 那么`java`是不是也是在堆区实例化对象呢? 带着疑问问了`ai`, 果然是. 
    - 由于看的日本老哥的第一个设计模式类型是抽象工厂模式, 所以也涉及到了上面`java`时期遇到的问题, 就是`new`对象时, 类名跟实例化对象名不相符, 我知道了, 这是多态的一种表现. 
    - 而《面向对象是怎样工作的》书中, 将我上面的想法又从底层解释了一下, `java`确实是从堆区实例化的对象, 不过`c++`跟`java`的不同, 是`c++`会在类创建阶段, 一次性将所有方法都创建出来, 而`java`会根据需要创建. 所以, 我在嵌入式用`c++`写的代码, 当时并不清楚是否会将所有方法一次性全部加载出来, 所以有很多重载方法, 问了`ai`, 记得说没问题, 不过目前看来, 是有问题的. 整体上来看, 这本书没有太大的难度, 头脑清晰了很多. 挺想一次性看完的, 不过才看到`100`多页, 还有`180`多页, 不着急, 每天看一两章就够了, 一口吃不成个胖子. 
        - 一本技术书, 个人如果有各方位知识的话, 看起来就很舒服, 如果从`0`想看一本技术书就集大成, 根本不可能. 假如这本书(《面向对象是怎样工作的》)放在半年前让我读, 可能根本看不明白. 但是学了嵌入式, 明白了底层`os`工作机理后, 在看这本书, 清晰简单. 以现在的理解程度, 再去看《`python`面向对象编程》这本书的话, 可能会有更加深入的理解. 可是七八个月之前看的时候, 似乎只理解极小部分的内容. 
        - 嵌入式学习过程, 课本一点没看, 全靠`ai`理解和动手实操. 等后续看书时, 太简单了, 简单得我都不想看了. 当然, 最后考试的时候, 还是过了一遍课本. 
        - 另外, 之前看数学类相关的书的时候, 尤其是线性代数书, 什么也不懂, 看起来非常非常难受. 后续结合实际实践过后, 再重新看书的话, 会有很大的不同. 
        - 之后可能还是会弄些新的东西, 比如`ffmpeg`, `vulkan`的时候, 直接看书肯定也是看不明白的, 所以一定需要靠`ai`, 建立自己的理解, 明白大部分的东西之后, 再去看书, 就会好很多, 这也算是一个前车之鉴吧. 
        - 那么问题就来了, 书, 到底是给懂的人看的呢, 还是给小白看的呢? 小白看本书, 真的就能会吗? 结合我自己的经历来看的话, 书是写给懂的人看的. 目前来看是这样的. 

### 认识
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-23 16:34:03  

&emsp;&emsp;上面说了这么多, 现在这里呢, 想再说一下自己的认识. 当然, 是学习层面的认识, 不是单纯的面向对象层面的认识. <br>

- 很早之前, 在上面层写过关键的"五条", 不知道是否还记得. 我现在摘要到下面. 
    - 良好的编写代码/运行代码的环境.
    - 良好的可视化的反馈.
    - 可参考的开源代码/书籍.
    - 兴趣驱动.
    - 问题驱动.
- 这是十分关键的五条, 在之前我的学习中, 有了很大的帮助, 之后肯定也会有帮助. 
- 不过, 上面只是告诉了方法, 能够直接套公式, 是非常好的(当然, 我的面向对象设计的学习, 无法套公式. 但这种情况还是比较少的). 可是并不代表着你这么做后就成了. 因为少了一个很关键的"东西". 当然, 这个"东西", 并不属于方法, 所以我肯定不会归并到上述五条之中. 那么这个"东西"是什么呢? 先举几个例子, 卖个关子, 哈哈. 
    - 记得在高中时期, 我学三角函数非常非常快. 当然, 并不是因为提前学了, 而是建立了自己的认识. 这所谓的认识, 用我现在的话来说的话, 就是理解, 或者是心理表征. 大致意思就是, 根据`a`内容, 我会在心中设想并建立模型. 之后将`b`内容放入, 看看是否符合这个模型. 符合的话, `ok`, 再看`c`内容. 不符合, 那就重新建模. 直到能符合所有情况. 这样后续做题的时候, 对应知识点, 套入对应模型, 得出结果即可. 
        - 当然, 不是`100%`建模成功的. 记得有次物理热学相关的内容建模后, 以为可以了, 考试时错了很多, 后续发现建模失败, 哈哈. 
    - 大学时, 也有这种建模思想, 但是没有好好地归整一下, 现在感觉是时候归整一下, 所以来这里分析分析. 
        - 首先是嵌入式, 别人写好的`c`, 我不愿意完全纯抄代码, 我期望自己能按照脑子里想的进行写. 所以每一块内容都会进行建模, 在脑海里形成自己的理解/心理表征, 这样之后, 我就能按照自己的想法写代码了, 而不受限于别人的代码了. 
            - 说的是很简单, 但实际中, 不仅仅是代码问题, 还有硬件理解问题, 软硬件知识匹配之后, 才能很好地`diy`代码. 
        - 后面的`neovim`配置, 也是一个道理, 先跟着别人的写, 建模之后, 会有自己的理解, 这样就可以按照自己的思想, 配置了. 
        - `cmake`, `os`底层编写, 都是一个道理. 数据库也是同理. 算法/数据结构也是. 
        - 上面的面向对象设计, 其实也是一个道理, 只不过相对于上面说的, 面向对象设计需要经验积累. 我为什么觉得这么困难呢? 就是因为难以在心中建模, 难以按照自己的思想写代码. 
            - 这其实也就解释了, 为什么一开始我的目标, 只是将`cpu`内部运行态, 用`python`编写一下, 发现自己很难建模后, 问了`ai`, 而`ai`能给出较为完美的答案, 我却不愿意用的原因. 我期望能按照自己的思想编写代码, 而不是被`ai`所控. 
- 说了这么多, 所谓的"东西", 应该也显而易见了. 其实就是在心中建模, 或者说有自己的认识, 或者说, 有自己的理解. 但这些都是大白话, 我还是用心理表征这个词吧(之前提到过, 这里不再重复解释了). 
- 建立自己的心理表征, 非常非常重要. 它代表着我们对某一个事物的理解程度. 
- 我觉得, 越熟悉的东西, 越容易建立自己的心理表征. 而将不相关的事物, 跟自己熟悉的东西建立联系, 这个不相关的事物, 也能形成自己的心理表征. 
- 带着自己心中特有的心理表征, 去看相关书籍时, 会异常地轻松. 相反, 缺乏自己的心理表征, 看某本书籍的话, 会非常困难. 这种困难, 也导致你很难从这本书中获取自己的心理表征. 
    - 我现在做的一切, 其实就是在给学习新事物建模, 形成心理表征. 后续学习其他新的东西的话, 有了自己的底层逻辑(心理表征), 也就没有什么畏惧了, 如何轻松地学习新的事物, 也就变得很容易了. 
- 随着了解的东西越来越多, 建模也就变得愈发轻松(当然, 我现在还没到这种境界, 所以猜测的)
- 大学以来, 我自己建立的几乎所有的心理表征, 似乎都不是从书上获取的(肯定也有, 《矢量分析与场论》这本书, 看了之后醍醐灌顶(为什么能在这里提一嘴呢, 因为它给我留下了深刻的心理表征, 哈哈). 当然, 有很多前缀知识的积累), 也不是看视频获取的, 也不是听老师讲课听懂的(记得高数上一开始的部分, 总是分析不明白, 期望上课能听懂, 但是认真听后, 并没有听懂...不过之后还是靠自己建了一个不错的模, 高数成绩考得也十分不错). 那么是怎么来的呢?
    - 首先, 完全靠自己脑子抽象. 但是大学的东西, 跟高中完全不一样, 很难的东西也就很难去抽象. (用高中知识对大学内容抽象, 根本不可能, 哈哈)
    - 其次, `ai`协助抽象. 仔细思考一下, 确实是这样的, `ai`帮助了我很多很多. 之前的内容, 我一直在强调, `ai`如何如何帮助我理解的, 其实就是`ai`帮助我在心中建了一个比较好的模, 或者说, 形成了很好的心理表征. 
    - 最后呢, 其实就是应用实践, 获取反馈. 大部分情况下, 自己的心理表征是没有问题的. 如果有问题的话, 这个问题本身, 其实就是一个很好的心理表征. 
        - 为什么怎么说呢? 比如, 在`neovim`的`lsp`配置中, 循环问`ai`, 循环错. 自己一直思考着为什么. 等问题解决后, 总是会先回想起错误, 再想起怎么做的. 这就是说, 问题的本身, 尤其是复杂问题, 其本身就是一个非常好的心理表征. 
        - 其它的实践, 比如`cmake`, 按照自己的思想配置后, 总会报错, 那么就会找错误. 等完美运行后, 我也就有了自己的认识. 
        - 等等等等. 不再举例了. 上述两个例子, 其实上面都提到过. 
- 那么如何理解心理表征呢? 
    - 当我们遇到一个函数, 知道其输入输出的话, 其实根本不用知道它实现的具体过程. 
    - 但这样会存在一个问题, 就是难以形成自己的理解. 理解从何而来? 完全从函数名中而来. 
        - 比如这个函数, `write(flie, str)`, 从函数名可以知道, 它可能是传入一个文件句柄和一个字符串, 效果是在这个文件中显示这个字符串. 
        - 或者我们更为熟悉的, `printf()`, `scanf()`等等, 我们不知道其内部实现细节, 但知道怎么用, 以及其效果是什么, 就足够了. 
    - 或许, 你可能会说, 这跟心理表征有什么关系吗? 其实非常有关系. 对函数的理解, 其实就是心理表征. 
    - 如果一个函数, 只知道输入输出, 实现部分完全是黑盒态, 你能说有自己的理解吗? 
    - 感觉这跟我之前的思想, 已经完美地闭环了. 会用各种库, 算不了什么, 会写才是王道. 
    - 如果我们将整个学习过程, 抽象为函数原理实现的部分, 那这不就是心创建心理表征的过程吗? 
    - 简单点来说, 就是知识, 通过自己的创建心理表征的过程, 映射为了自己的心理表征. 
    - 用函数来说的话, 就是输入输出分别是知识和心理表征. 也就是将不理解的东西, 通过某抽象函数的作用, 转化为了我们自己理解的心里表征. 而这个抽象函数, 就是心理表征创建的过程, 也就是我们理解的过程. 
    - 所以, 编程中的某个函数, 我们不懂的话, 一般会选择问`ai`, 并建立一定的认识. 学习其实也是一样的. 
- 感觉说的真好, 都分析完了. 现在感觉靠着`ai`, 什么东西都能学了, 哈哈. 散会!

### 其它
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-24 20:02:43  

&emsp;&emsp;刚才, 又看了`C++`创始人本贾尼的经历历程, 里面有这么一句话:"课余时间, 本贾尼喜欢上了一本书, 书名是《为数字计算机构建编译器》, 作者大卫·格里斯. **这本书使本贾尼对编程语言产生了兴趣**, 他懂得了如何实现一种编程语言. 读大学期间, 本贾尼一共学习了`20`多种编程语言."<br>
&emsp;&emsp;又是产生兴趣. `Linus`编写`Linux`, 也是因为兴趣. 当然, 本贾尼编写`C++`, 更多地可能是为了解决实际问题, 兴趣或许只是一个方面. <br>
&emsp;&emsp;兴趣也是我之前提到的五条中的第四条, 也是我认为最最重要的一条. 缺少了兴趣这个内驱力的话, 根本无法谈起主动学习. <br>
&emsp;&emsp;另外, 看了二者的经历, 虽然是搞计算机的, 不过对硬件都有很深的理解. 可能是当时所处时代的原因吧. 但是现在呢, 我们很少触碰硬件. 虽然有各种实验, 但是真的将实验模拟成了"实验"吗? 更多人可能是, 这种想法: 兴趣? 没有, 学校这么安排了, 我就这么做. <br>
&emsp;&emsp;我现在弄的嵌入式板子呢, 是安装好了的, 几乎不用手动调用, 软件端烧录一下就可以. 其它的东西呢, 像`os`, 上面也说过了, 尝试去买实体, 但是没有合适的, 最后还是选择了软件模拟. 不过, 这些做的实验, 我确实都是带着脑子, 真实模拟实验的. 以前学校相关的硬件实验, 比如计算机组成原理, 当时没有领悟, 没好好做, 确实比较可惜. 好在现在的嵌入式实验跟`os`实验, 认真做了, 也有了一定的硬件理解. 不过, 确实缺少手上的真实硬件, 也不知道具体从哪去弄. <br>
&emsp;&emsp;回想一下我嵌入式中的一些模拟, 比如最后做的那个综合实验, 在`lcd`屏上滑动滑动, 可以调节电机转速, 滑动另一个滑块, 可以调节小灯亮暗. 这跟手机上的滑动滑块不一样, 已知信息只有能在屏幕上显示矩形. 我知道可能有其他的库去实现丝滑的效果, 但是我不想去用库, 只想根据当前已知信息, 去模拟实现一下. 问题其实也很明确, 就是如何让滑块动起来呢? 问`ai`也确实问不出来啥, 只能自己去思考. 最后实现的效果就是, 写好定时器中断, 每`10ms`检测有无按压. 没有按压, 不做任何逻辑判断. 如果有按压, 就会判断是否在目标范围内. 如果不在, 就不进行任何动作. 如果在的话, 就会记录当前`x`值, 并且刷新屏幕, 更新滑块位置. <br>
&emsp;&emsp;其实就是挺简单的, 不过由于`LED`灯对应的管脚, 没有`PWM`功能, 只能去调节电机. 但是, 没有任何参考, 一开始完全不知道如何模拟滑块滑动, 如何将滑块`x`值跟电机绑定, 确实很困难的. <br>
&emsp;&emsp;而显示效果呢, 也确实是存在问题的. 刷新整个屏幕, 再重新画滑块, 显示效果就很不丝滑. 其实最一开始的想法是只刷新滑块位置, 不过由于是在自己的电脑上写的代码, 不是实验室中的电脑, 所以也没法调试. 最后只能刷新整个屏幕, 再显示滑块, 这种最简单的方案. <br>
&emsp;&emsp;当然, 从这里学到了很多, 也有很多疑问, 比如像我们手机, 电脑, 这么丝滑地显示, 这种效果是如何实现的呢? <br>

&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-25 19:04:44  

&emsp;&emsp;刚才又认识到了深度`copy`的用处. 以前也知道深度`copy`, 但是解决了什么实际问题呢? 确实十分不清楚. 现在知道了底层硬件, 底层`os`运作原理之后呢, 一切变得很清晰了, 来看下面的代码吧. <br>

~~~lua
local capabilities = require('cmp_nvim_lsp').default_capabilities()
capabilities.textDocument.completion.completionItem.snippetSupport = false
local lsp_data = require("data.plugin_data").lsp_data
local servers = lsp_data

for _, lsp in ipairs(servers) do
  if lsp == "html" then
    local caps = vim.deepcopy(capabilities)
    caps.textDocument.completion.completionItem.snippetSupport = true
    vim.lsp.config(lsp, { capabilities = caps })
  else
    vim.lsp.config(lsp, { capabilities = capabilities })
  end
end
~~~

&emsp;&emsp;本来在`html`之前, 上面所有的`capabilities.textDocument.completion.completionItem.snippetSupport`, 都是`false`. 但是配置`html`的`lsp`的时候呢, 这里必须为`true`. 没有办法, 我只好单独将`html`拿出来, 然后给其弄上`true`. <br>
&emsp;&emsp;不过, 第一次的时候, 并没有用`deepcopy`, 而是遇到`html`后, 之前的变量, 变为`true`, 配置完后, 再变回`false`. 这样理论上, 也可以. 但是反馈却不对. 问了`ai`, 说需要用到深度`copy`, 我就明白了. 不论再怎么修改, 都是同一个变量, 地址相同. 虽然中间改了值, 但是, 后面又改了回去. 所以对于`html`, 其配置仍然为`false`. 而上面呢, 我采用了深度`copy`, 这样会在另一块地址赋值, 并且不会相互影响了. 修改过后, 反馈正常. 妙啊, 确实妙. <br>

&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-27 10:47:29  

&emsp;&emsp;今天跟同学问我, 一个学生考试科目冲突了怎么办? 我说, 这或许就是缓考存在的意义. 他又说, 那学校是如何安排的呢? 我说了一个最简单的方案, 就是同一个时间段内, 只允许一门考试科目, 这样就不存在考试科目冲突的情况. 随后又说, 可以先看公共考试科目, 比如大物, 这样其它专业的考试需要避免相同时间段内考试. 之后, 各个学院的其他专业考试可以选择除此之外的时间段内考试. 后面他又说, 只是看这一个学生等等等等. <br>
&emsp;&emsp;这让我想到, 怎么跟面向对象这么像呢? 我跟他说, 只分析这一个对象, 很难确定考试科目是否冲突. 但是, 从宏观上来看, 站在学校角度分析整个类的话, 会比较明确. <br>
&emsp;&emsp;之前, 在面向对象那里, 我曾说过, 分析单一对象而不是分析整个类. 但是目前结合实际来看的话, 似乎分析类, 比分析单一对象要更容易. 那么实际中, 我们应该如何分析呢? <br>

&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-27 19:12:28  

&emsp;&emsp;哎, 这搜狗输入法真的是服了. 之前默认自动更新, 总会将我的一些自定义配置给重置了, 于是我关闭了自动更新. 后面, 前两天, 终端打字突然就不显示输入法了, 那两天过的比较难受, 打字很不舒服, 而且`vim`打字也会受到影响. 主要是还找不到错误原因, 不知道是终端引起的还是输入法引起的. 刚才束手无策下, 选择了更新输入法, 更新之后, 问题就消失了......国产软件为什么总是这么恶心人呢???也不是说国外软件好, 毕竟用的少. 感觉可能是平时白嫖习惯了...<br>

&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-29 21:08:47  

&emsp;&emsp;总是有很多想说的, 但是不知道写在哪, 索性还是直接写在这里吧, 虽然还是有些偏离初心了. <br>
&emsp;&emsp;上周较为深入地学习了操作系统, 并且在这周天较为成功地完成了考试. 怎么学的呢? 很简单, 就是看书+学习通上老师发布过的题目. 学到了很多东西, 但是我觉得最关键的是如何看书. <br>
&emsp;&emsp;看书其实很简单, 如果看的是自己熟悉的领域的书的话, 其实就非常非常明确, 大部分的名字, 一看就知道什么意思. 比如嵌入式, 我自己学的时候, 并没有结合课本, 而是结合网上的资料. 等临考前复习的时候, 课本中的内容就变得非常非常简单, 甚至都不太想看了. <br>
&emsp;&emsp;可是如果看得是自己不熟悉的领域呢? 最典型的是高等数学, 线性代数. 虽然是基础学科, 但是, 我觉得还是缺少一些读书技巧, 看起来也是比较吃力的. 那么缺少了什么读书技巧呢? <br>
&emsp;&emsp;操作系统这里给出了答案. 看操作系统课本的时候, 不再是纯看了, 而是分析作者用词. 这些词, 这些专有名词, 如果搞不明白什么意思, 就很难往下进行. 因为后面可能会有越来越多的这种词汇, 一句话中这种词汇多了, 能看懂什么意思吗? 另外还有作者写的时候的思想, 想表达的意思. 想搞明白是非常困难的, 但是能略懂一二, 其实也就足矣. 比如我自己, 写了这么多, 有些地方想表达的含义, 我自己最清楚, 而看这句话的人, 能领略我的意思吗? 由于懂作者的意图, 非常困难, 不在这里的讨论范围内. 我这里主要想说分析作者用词. <br>
&emsp;&emsp;怎么分析作者用词呢? 首先, `AI`是个好帮手, 必然要靠`AI`的. 之后, 就是对这些专有名词, 在自己心中映射一个常见的东西, 形成自己的心理表征. 这样每次看到这个专有名词, 就会首先想到自己的心理表征, 进而慢慢形成自己的理解. 当然, 这个映射建立过程, 肯定不是那么好建立的. 可是一旦建立, 每当看书时, 看到含有这个名词的话, 一下子就知道什么含义了. <br>
&emsp;&emsp;举几个操作系统例子, 常见的进程线程等的就不说了. 比如, 互斥, 异步. 这些在操作系统书里是十分常见的. 但是, 理解这种东西, 也不是说你将这些词问`AI`就能产生的. 互斥, 我想的是各种临界资源(这其实也是操作系统的专有名词). 比如打印机, 我用的时候你就无法使用了. 异步非常有意思. 确实是很难理解. 我是如何理解的呢? 我先假设一下它的反义词, 且成为同步(跟进程同步不是一个意思). 同步描述的是各种情况我们可以预料, 并且顺序确定, 是一种理想情况. 那么异步, 则是情况无法预料, 顺序难以确定, 是实际情况. 计算机所处的环境, 几乎都是异步环境. 这似乎也是操作系统存在的必要条件之一. <br>
&emsp;&emsp;所以, 操作系统这本书, 看得也很慢, 但是确实理解很深, 前面的几个章节, 一看就知道什么意思了. 这在计算机网络, 计算机组成原理的学习过程中从未有的体验. 当然, 可能跟当时没有太多的学习意识有关. <br>

## 2025/12/30
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-30 11:30:43  

&emsp;&emsp;可能你也注意到了, 上面最近的一节, 是`12.29`号的, 而这里新开的是`12.30`号的. 其实上面的没说完, 本来是在跑着计算机视觉算法的时候写的, 写到一半发现跑完了, 于是就去弄视觉的东西了, 上面的也就忘了弥补, 看起来戛然而止. 由于不知道做完还想写什么, 所以直接停笔了. <br>
&emsp;&emsp;按照我的尿性, 这两天离得这么近, 肯定会选择放一块的. 其实分开的原因也很简单, 主要是为接下来的数据库的内容做准备了. 目前来看, 写得很杂乱, 而且远离了我的初心(初心一开始应该说了). 但是主要的目的是数据库的`AI`使用报告. 不过还是那句话, **虽然大部分跟数据库没有关系, 但是确实是我自己实打实分析出来的, 我觉得还是具有参考价值的**. <br>
&emsp;&emsp;周天考完操作系统后, 我用两天时间(前天+昨天)的时间, 将所有杂乱的事项全部完成, 比如操作系统实验报告, 人工智能实验报告(这俩代码早就写好了, 就差报告了), 还有操作系统结课报告, 结课视频, 还有视觉的算法结课题目. 这些东西弄完后呢, 目标就很明确了, 只剩下数据库结课报告跟`web`结课报告了. 这俩还有一定的联系. <br>
&emsp;&emsp;`mysql`早就下载了, 但是那段时间一直搞着别的东西(其实就是上面说的), 我觉得还是根据兴趣有关系, 感兴趣的, 就愿意投入时间去弄, 不感兴趣的, 强迫去弄也没什么效果. 那段时间确实是对数据库没有太大的兴趣, 所以也就是做做实验(虽然总结了挺多东西, 但有些忘了, 不过影响不大). <br>
&emsp;&emsp;这两天, 想了想, `mysql`似乎也可以直接作为脚本语言运行, 问了问`AI`, 确实是, 但是跟终端脚本肯定是不同的. 那这样不就简单了? 我喜欢写脚本, 当做脚本写十分轻松, 语法能够快速掌握. <br>
&emsp;&emsp;当然, 这都不是最关键的, 关键的是对数据库层级结构有了认识. 这其实跟操作系统有很大的关系. 我终端用的很多, 对基本的树状结构很熟悉. 但是弄数据库的时候, 访问各类资源时, 总是感到很奇怪. 这种感觉很难说, 因为不是传统的树状结构. 学了操作系统之后呢, 对文件系统有了了解. <br>
&emsp;&emsp;随后问了`AI`下面的问题. "数据库是树状结构吗, 像操作系统那样, 还是层状结构? 我感觉不是树状结构. 你觉得呢?". 它的具体回答我就不说了, 简单来说, 就是管理角度来看, 是树状的, 但从数据语义来看, 是图结构. 这样就很明确了, 我也不用像以前一样纠结于查看的奇怪感觉, 只需要专心分析数据即可. <br>
&emsp;&emsp;有了上面那么多的学习经验, 再学习数据库就简单很多了. 五条中, 可能就缺少了问题驱动吧. 可视化方面呢, 就是学会展示各个内容即可, 跟着`AI`学习就好. 另外最关键的就是脚本运行, 其实也没什么难度. <br>
&emsp;&emsp;这几天专门潜心学习数据库了, 不多说什么了. <br>
&emsp;&emsp;对了, `sql`就不用`lsp`自动补全了, 毕竟是要考试的, 自动补全用多了, 也记不住, 考试也可能会写不上. 等考完之后再用`lsp`吧. <br>

## 2025/01/01
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2026-01-01 12:07:24  

新的一年了, 还是起来敲代码, 哈哈.
&emsp;&emsp;昨天本来写着数据库脚本, 写完之后, 想休息休息. 休息完后, 不知道为啥, 又想配置`vim`的脚本. 主要还是括号匹配还是达不到自己的理想状态, 也不是不能改, 但是怎么说呢, 这种感觉就非常奇怪. 所以, 想看看别人写的, 于是又问了`AI`, 找到一个合适的匹配插件去学习. 这个插件是`nvim-autopairs`. 我之前没用过, 虽然代码不长, 但是是结构化编写的, 不懂作者思想的话, 学习起来会非常困难. 后来结合`ai`, 了解了作者的设计思想, 并且逐渐明白了整体结构. <br>
&emsp;&emsp;不过却在测试上反了难. 怎么测试呢??? 如何内化为自己的呢? <br>
&emsp;&emsp;后来想了想, 这些都是跟按键映射相关的. 我自己的, 只是脚本配置, 没法控制映射开关, 导致的问题就是, 不能随意取消映射(可以是可以, 但是太麻烦了). 这也是痛点所在. 如果整体配置了一个开关, 可以随时取消映射, 多么好啊! <br>
&emsp;&emsp;这也怪不了别人. 刚开始写的时候, 没有任何思想, 能按照自己想法来写, 达到效果就行. 现在是学习别人的思想, 掌握整体结构化编写, 可以灵活控制. 或许一开始确实是比较困难, 但是迈过了这个坎, 一切就都会容易很多了. <br>

### 问题
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2026-01-03 11:15:58  

&emsp;&emsp;昨天写着`QT`前端的时候, 发现了一个很严肃的问题, 还是编程学习层面的问题. 比如说写`cmake`, 基本道理都懂, 但是, 必须对着以前写好的`cmake`脚本来写, 因为里面的函数记不住, 但是看到这个函数知道它有什么用处. 另外, 对它底层搜索原理也比较明确, 但是那些都是自己写的`c++/c`的代码, 如果需要外接库, 比如说`qt`, 那么, 通过`cmake`联系的话, 必须知道外接口提供的`cmake`接口, 否则仍然是无法正常编译的. <br>
&emsp;&emsp;上面是举的一个例子, 下面就将我详细问`ai`的问题给贴出来参考一下吧. <br>

`你好, gpt, 我现在遇到了一个十分严峻的问题. 
学习层面, 而且是编程学习层面的问题. 
以前, 我刚学习编程, 懵懵懂懂, 很害怕学习新的东西. 我仔细分析拆解了一下, 发现 , 我仍是高中模式学习编程: 重复练习, 以期望记住. 可是速度 缓慢, 不过还是有些用的, 但是仍无法拜托害怕学习新东西的心理 . 
后来, 我反思了一下, 觉得, 我主要担心自己如何记住(背过?). 因为看别人灵活地敲代码很帅, 但是自己却没有这个能力. 之后, 我想明白了, 学习编程, 考得不是记住, 而是理解, 知道什么意思就行了. 最关键的理论是, 记不住, 是因为用得少, 用得多了, 自然就记住了(对吗?). 所以, 我的模式, 由记住代码, 变成了理解代码. 
现在呢, 我确实具备了快速理解代码的能力. 但是, 我发现, 理解是理解了, 却仍然记不住, 需要对着写. 不过, 对着写, 我能知道每个代码的意思. (可能是因为我换了neovim, 有些语言没有lsp, 不如vscode等灵活, 所以, 代码总是记不住(比如函数名什么的), 总是要靠ai或者是对着写好的代码写). 
目前怎么弄呢, 总是学的不深入. 比如面向对象设计, 或者是neovim插件复刻, 亦或者是其他的学习, 总是学的不深入, 浮于皮毛. 这种感觉, 跟以前不会学的感觉很不一样, 但是却没有办法. 怎么办呢? 你有没有好的学习编程层面的见解呢? `

&emsp;&emsp;当然, 它给我的答案并不怎么样. 不过它提到了一个词, "有意练习". 这跟我之前看的《刻意练习》, 感觉是一个意思. 之前我说过了, 这本书我就看了一半, 就能解决我自己当时的困惑了. 而现在深入实践之后呢, 又存在了困惑, 所以我觉得, 还需要重新看看这本书. <br>
&emsp;&emsp;之后就上床睡觉了. 直到今天早上起来, 我觉得我可能想明白了. <br>
&emsp;&emsp;简单的重复(总是对着写), 很难在心里留下心理表征. 上面问`ai`的总结中说过, "记不住是因为用的少", 这句确实没问题. 可是后面的"用得多了, 自然就记住了", 这句肯定是错了. 因为在我看来, 记住, 需要在心里留下心理表征, 而用得多, 并不代表在心里留下心理表征. 比如, 我们想背一篇古诗文, 如果我们读这篇古诗文成百上千遍, 你觉得会记住吗? 离开课本让你自己背, 能背过吗? 大概率是背不过的. 为什么? 因为读是最容易的了, 谁都能干, 最关键的是无法在心中留下心理表征. 这样, 脱离课本后, 即使你读了无数遍, 仍然无法背过. <br>
&emsp;&emsp;写`cmake`也是一个道理, 虽然我都理解了整个运行流程(就好比我们理解了古诗文的含义), 而且, 对着其他写好的`cmake`, 能对这些新的程序写出新的`cmake`脚本(好比我们读古诗文), 可重复无数遍, 仍旧无法单独自己写`cmake`脚本(好比我们重复读了无数遍古诗文). 这就是问题所在. 所以说, 当我们背古诗文的时候, 肯定要脱离课本, 让自己深陷痛苦之中. 我们有背诵古诗文的技巧, 比如说一段一段地去背. 但这并不会留下心理表征. 而将每一段联系起来的过程, 才是关键的心理表征(当我背诵完这一段, 需要联想下一段是什么). 编程层面呢, 肯定不会是像背古诗文这样死板, 背代码, 从刚入学我们就知道是错误的. 但是我们需要让自己深陷痛苦之中, 也就是远离抄写之前写好的代码. 当然, 这只是学习层面, 后续工作的话, 肯定会复制粘贴, 谁还会去抄, 哈哈. <br>
&emsp;&emsp;回顾一下, 一开始, 我会像高中那样, 重复练习, 以期记住. 后来发现是错了, 改变观念, 变成了需要高度理解. 现在发现, 只有理解还远远不够, 仍需要练习, 但不是重复练习, 而是深陷痛苦中的那种练习, 摆脱一切舒服因素, 让自已留下心理表征. 其实就是刻意练习(直接用现有词语了, 哈哈). <br>
&emsp;&emsp;深层次理解+刻意练习=王炸.<br>
&emsp;&emsp;其中, `AI`可以帮助我提升理解, 但是刻意练习`AI`完全无法给予. 怎么能让编程在自己心中留下心理表征呢? 目前还没有解决方案, 毕竟是刚发现问题. 后续实践之后再来分析吧. 但找到了自己问题所在, 还是很有意义的, 这样就无需重复踩坑了. <br>

## 2026/02/06
&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2026-02-06 21:38:49  

### 近况
&emsp;&emsp;好久不见, 哈哈. 好久没写这个了. 这玩意后面当做数据库的`ai`使用报告, 在数据库结束之后也就没再碰过了. 从`1`月`1`号初, 到`1`月`24`号, 整体上都是十分繁忙了, 确实没太有空.首先, 有数据库结课项目跟`web`结课项目这俩大头, 其次还有数据库, 人工智能这俩考试, 最后还有一个实训项目. 数据库结课项目和实训项目是团队分工的, 但是到头来看, 差不多都是自己完成的, 有点无语...<br>
&emsp;&emsp;所以对我自己来说, 确实是非常非常非常非常地累, 但也确实学到了些东西, 有了一定的理解把.<br>
&emsp;&emsp;当然, 这个文档主要还是用来记录自己学习过程中的烦心事的. 什么东西影响学习效率了? 什么让我没有动力学习呢? `1`月`24`号放寒假后, 确实很乱很乱, 不过到现在已经缓过来大部分了, 下面就详细说明一下吧.<br>

### 问题
- 刚开始的两天, 打算先休息休息, 然后写了一个寒假计划报告, 用于激励自己学习.
- 但实际上, 这个报告没啥用, 只是拿出时间来写写, 装作有事的样子.
- 后续的几天, 尝试看`C++`相关的视频, 但是总感觉有些奇怪. 视频是侯捷老师讲的, 不是说讲的不好, 而是感觉没办法整理和记录, 找不到自己舒服的方式学习.
- 之后看短视频了解到了一个西蒙学习法的方法, 感觉很有效.
- 我自己也反思, 之前的学习方式, 是不是存在问题?
    - 整理的万字文档, 有多少自己愿意回看分析呢? 即使分析, 真的能看进去吗?
    - 总是跟`ai`学习, 但是都是零散学习, 像`cmake`, 嵌入式`c++`这些东西, 真的学会了吗? 使用的时候为什么还总会看着以前写好的东西写呢?
- 为什么会这么感觉呢? 因为我觉得, 在项目中学习, 确实能建立理解, 但是缺少联系, 真正独立使用的时候, 肯定摆脱不了`ai`.
- 而西蒙学习法, 是去寻找`chunk`, 费曼学习法则是建立自己的理解, 这俩结合起来, 简直就是王炸.
    - 我自己以前是秉持理解优先的原则, 类似费曼学习法. 但是理解是理解了, 应用起来却很不熟练.
    - 在`manim`学习时期, 还没有建立理解优先的思路. 那个时期没有方法, 没有学过其它库的经验, 只能独自摸索. 每时每刻都在重复, 仿佛高中化的学习, 偏向于记忆.
    - 前者的理解优先, 离开不了`ai`, 离开不了写好的代码, 只能对着抄, 因为自己十分清楚什么意思, 一看就懂. 可是这样无法自己独立去写, 说白了, 那些函数名什么的是记不住的, 因为没有刻意练习.
    - 后者则类似高中学习思路, 就像背单词, 害怕忘记, 那么就遵循艾宾浩斯遗忘曲线. 这种方式呢, 完全不用`ai`, 也不用看以前写好的代码, 熟练之后几乎能做到想干什么就干什么, 而西蒙学习法类似这种学习思路.
- 后续呢, 我就打算找一个能当`chunk`的东西. 首先选择的是`graphviz` + `puml` + `git`, 但是存在问题, 总是让我感到不舒服. 
- 那段时间呢, 也总是寻找好用的工具, 学习效率几乎为`0`, 缺少动力.
- 后续找到了一个好的软件, 叫做`anki`, 十分地适合啊!!.
- 但是发现入手难度比较高, 因为我想要自定义卡牌, 而且需要美化, 要求很高, 所以也很容易让我气馁.
- 之后的一天又是一直在网上找其他可替代方案, 最后发现还是使用`anki`吧.
- 然后的一天是自己`diy anki`模版, 最后优化地差不多了, 便慢慢开始使用了.
- 今天呢, 是比较完整地使用的一天, 感觉效果不错. 虽然学习效率不高, 但是动力是有了.
- 制作的每一张卡片, 其实就是一个`chunk`, 符合西蒙学习法. 然后呢, `anki`又差不多遵循艾宾浩斯记忆往事回顾每个卡片, 也是符合西蒙学习法的要求的. 每一个`chunk`里, 会有自己独特的理解, 也符合费曼学习法了.
- 今天的感觉是关于`C++`基础部分, 建立了很深的理解. 以前可能迷迷糊糊, 懵懵懂懂, 不愿意看的地方, 现在研究地比较深入了.
- 后续会怎么样呢? 拭目以待吧.
